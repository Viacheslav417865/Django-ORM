# Django-ORM

**Django ORM**

## **Що таке база даних?**  **What****is****database****?**

**База даних (database****)** --- це організована колекція даних, яка зберігається та керується за допомогою програмного забезпечення для управління базами даних (СУБД). Дані в базі даних зазвичай зберігаються в таблицях, де кожен рядок містить запис, а кожен стовпець --- окрему характеристику цього запису.

Основні характеристики бази даних:

-   Структура: Вони мають чітку структуру, зазвичай це таблиці з даними, що складаються з рядків і стовпців.
-   Запити: Для пошуку, додавання, оновлення та видалення даних використовуються спеціальні мови запитів, такі як SQL (Structured Query Language).
-   Інтеграція: Бази даних дозволяють зберігати великі обсяги даних та зручно працювати з ними, а також інтегрувати з іншими системами.
-   Безпека: Бази даних забезпечують захист даних через контроль доступу, резервне копіювання та відновлення даних.

Типи баз даних:

1. Реляційна база даних (RDBMS): Зберігає дані в таблицях і дозволяє використовувати SQL для запитів (наприклад, MySQL, PostgreSQL).

2. Нереляційна база даних (NoSQL): Використовує інші способи зберігання даних, наприклад, у вигляді документів або графів (наприклад, MongoDB, Cassandra).

3. Об'єктно-орієнтована база даних: Зберігає дані як об'єкти, які є частинами програмування об'єктно-орієнтованих мов.

## **Що таке SQL?** SQL

**SQL (Structured Query Language)** --- це стандартна мова для взаємодії з реляційними базами даних. Вона використовується для запиту, управління та маніпулювання даними в базах даних. SQL дозволяє створювати, змінювати та видаляти таблиці, а також виконувати різноманітні операції з даними, такі як пошук, оновлення або видалення.

Основні функції SQL:

o **Запити на вибірку даних (SELECT)**: Використовується для отримання даних з бази даних.Наприклад: SELECT * FROM  employees; --- вибирає всі дані з таблиці "employees".

o **Додавання даних (INSERT****)**: Використовується для додавання нових записів у таблицю. Наприклад: INSERT INTO employees (name, age) VALUES ('John', 30); --- додає  новий  запис  у  таблицю  "employees".

o **Оновлення даних (UPDATE****)**: Використовується для оновлення існуючих записів у таблиці. Наприклад: UPDATE employees SET age = 31 WHERE name = 'John'; --- оновлює вік працівника на 31 для запису, де ім'я --- "John".

o **Видалення даних (DELETE****)**: Використовується для видалення записів із таблиці. Наприклад: DELETE FROM employees WHERE name = 'John'; --- видаляє  запис  працівника  з  ім'ям "John".

2. **Створення таблиць (CREATE TABLE)**: Використовується для створення нової таблиці в базі даних.

o Наприклад:

CREATE TABLE employees (

 id INT PRIMARY KEY,

 name VARCHAR(100),

 age INT

);

3. **Зміна структури таблиць (ALTER TABLE)**: Використовується для зміни структури існуючої таблиці (наприклад, додавання нових стовпців).

o Наприклад: ALTER TABLE employees ADD email VARCHAR(100); --- додає новий стовпець "email" у таблицю "employees".

4. **Видалення таблиць (DROP TABLE****)**: Використовується для видалення таблиці разом з усіма її даними.

o Наприклад: DROP TABLE employees; --- видаляє  таблицю  "employees".

**Чому SQL важливий?** SQL є основним інструментом для роботи з реляційними базами даних. Він дозволяє користувачам та програмам взаємодіяти з даними, зберігати їх, шукати та обробляти інформацію, що важливо для багатьох застосунків, таких як веб-сайти, системи управління даними, фінансові системи тощо.

## **Що таке параметризація (****SQL****-ін'єкція)? ****What is parametrization (SQL-injection)?**

**Параметризація**  в  контексті SQL та **SQL-****інєкція** --- це  важливі  поняття  в  сфері  безпеки  баз  даних  і  веб-розробки.

**Параметризація:**Параметризація (або **підготовлені запити**) --- це метод безпечного виконання SQL-запитів, який дозволяє передавати значення параметрів у запит без їх безпосереднього включення в сам SQL-код. Це важливо для захисту від SQL-ін'єкцій.У параметризації значення параметрів (наприклад, введені користувачем дані) передаються окремо від самого SQL-запиту, що гарантує правильне їх оброблення та запобігає ризику виконання шкідливого коду.

Приклад параметризації в SQL (на мові програмування, наприклад, Python з бібліотекою sqlite3):

cursor.execute("SELECT * FROM users WHERE username = ? AND password = ?", (username, password))

У  цьому  прикладі  значення username та password передаються  як  параметри  запиту, і  вони  не  можуть  бути  безпосередньо  виконані  як  частина SQL-коду.

**SQL-****ін****'****єкція****: SQL-****ін****'****єкція** --- це  вид  атаки, при  якому  зловмисник  вставляє  шкідливий SQL-код  у  поле  вводу, наприклад, у  форму  для  логіну  чи  пошуку  на  вебсайті, з  метою  маніпулювання SQL-запитами, що  виконуються  на  сервері  бази  даних.

Простий  приклад SQL-ін'єкції: Якщо  вебсайт  не  використовує  параметризацію  та  дозволяє  безпосередньо  включати  введені  користувачем  значення  в SQL-запит, то  зловмисник  може  ввести  таке  значення  в  поле "ім'я  користувача":

' OR '1'='1

Це змінить запит на:

SELECT * FROM users WHERE username = '' OR '1'='1' AND password = 'password';

В результаті цей запит може повернути всі записи з таблиці, або дозволити зловмиснику увійти в систему без знання пароля (якщо логіка дозволяє це).

**Як параметризація захищає від SQL-ін'єкцій?**

Параметризація запобігає SQL-ін'єкціям, оскільки значення параметрів передаються окремо від самого SQL-запиту. База даних сприймає їх як прості дані, а не як частину SQL-коду, що запобігає виконанню шкідливих SQL-команд.

**Приклад без параметризації (уразливий):**

cursor.execute(f"SELECT * FROM  users  WHERE  username = '{username}' AND  password = '{password}'")

Якщо користувач введе:

' OR '1'='1

то запит стає уразливим до ін'єкції.

**Приклад****з****параметризацією**** (****безпечний****): **cursor.execute("SELECT * FROM users WHERE username = ? AND password = ?", (username, password)) Тепер  значення  параметрів  обробляються  окремо, і SQL-ін'єкція  неможлива.

**Важливість****параметризації****:**

Параметризація  є  одним  з  основних  способів  захисту  від SQL-ін'єкцій, які  є  однією  з  найпоширеніших  вразливостей  веб-додатків. Вона забезпечує безпеку, запобігаючи виконанню несанкціонованих SQL-запитів, що може призвести до витоку даних або знищення інформації.

## **What is connection/cursor? ****Що****таке****підключення****/****курсор****?**

Підключення (connection) та  курсор (cursor) --- це  два  важливі  компоненти  при  роботі  з  базами  даних, особливо  в  контексті  виконання SQL-запитів  через  різні  мови  програмування, такі  як Python, Java, PHP тощо.

1\. Підключення (Connection):Підключення --- це  зв'язок  між  програмою  (наприклад, Python-скриптом або веб-додатком) та базою даних. Воно дозволяє програмі відправляти SQL-запити до бази даних і отримувати відповіді від неї.

-   Призначення: Підключення встановлює з'єднання з сервером бази даних, що дозволяє програмі взаємодіяти з базою, виконувати запити (наприклад, SELECT, INSERT, UPDATE) та отримувати дані.
-   Як це працює: Для встановлення підключення програмі необхідно вказати інформацію для підключення (ім'я користувача, пароль, хост, порт тощо).

Приклад у Python (використання sqlite3):

import sqlite3

# Створення підключення до бази даних SQLite

connection = sqlite3.connect('my_database.db')

В  цьому  прикладі connection є  об'єктом, який  представляє  відкрите  підключення  до  бази  даних my_database.db.

2\. Курсор (Cursor):

Курсор --- це  об'єкт, що  дозволяє  програмі  взаємодіяти  з  базою  даних  і  виконувати SQL-запити. Він є "вказівником", через який виконуються запити та отримуються результати. Призначення: Курсор використовується для виконання SQL-запитів, отримання результатів та обробки даних. Він є посередником між програмою і базою даних. Як це працює: Після того, як підключення до бази даних встановлено, створюється курсор, через який здійснюються SQL-запити та отримуються дані.

Приклад у Python (використання sqlite3):

# Створення об'єкта курсора з підключення

cursor = connection.cursor()

# Виконання  запиту  через  курсор

cursor.execute("SELECT * FROM users")

# Отримання  результатів  запиту

rows = cursor.fetchall()

print(rows)

# Закриття курсора після використання

cursor.close()

В цьому прикладі:

-   cursor = connection.cursor() створює курсор з підключення.
-   cursor.execute("SELECT * FROM users") виконує SQL-запит.
-   cursor.fetchall() отримує  всі  рядки, які  повертаються  запитом.

Ключові відмінності між підключенням та курсором:

1. Підключення:

o Представляє з'єднання з базою даних.

o Використовується для аутентифікації та встановлення зв'язку з сервером бази даних.

o Підключення зазвичай створюється один раз на сесію і закривається, коли більше не потрібне.

2. Курсор:

o Використовується для виконання SQL-запитів та отримання результатів.

o Курсори створюються для кожного запиту та закриваються після того, як отримано необхідні дані.

o Підключення може мати кілька курсорів, якщо потрібно виконувати кілька запитів одночасно.

Як це працює в загальному:

1. Створення підключення: Програма створює підключення до бази даних.

2. Створення курсора: З підключення створюється курсор.

3. Виконання запитів: Через курсор виконуються SQL-запити.

4. Отримання результатів: Курсор отримує дані за допомогою методів, таких як fetchall() або fetchone().

5. Закриття курсора та підключення: Курсор та підключення закриваються після завершення роботи.

## **CRUD**

**CRUD**** --- **це абревіатура, яка позначає основні операції, що виконуються з даними в системах управління базами даних (СУБД) та додатках, які працюють з ними.

Розшифровка CRUD:

1. C --- Create (Створення)

2. R --- Read (Читання)

3. U --- Update (Оновлення)

4. D --- Delete (Видалення)

Ці чотири операції є основними діями, які здійснюються для управління даними в базах даних або в додатках, які їх використовують.

Пояснення кожної операції:

1. Create (Створення):

o Операція, яка дозволяє додавати нові записи в базу даних.

o Це зазвичай відбувається через SQL-запит INSERT INTO.

o Приклад: Додавання нового користувача в базу даних.

INSERT INTO users (name, email) VALUES ('John Doe', 'johndoe@example.com');

2. Read (Читання):

 Операція, яка дозволяє отримувати дані з бази даних.

 Це зазвичай відбувається через SQL-запит SELECT.

 Приклад: Отримання списку всіх користувачів.

SELECT * FROM users;

3. Update (Оновлення):

 Операція, яка дозволяє змінювати існуючі записи в базі даних.

 Це зазвичай відбувається через SQL-запит UPDATE.

 Приклад: Оновлення адреси електронної пошти користувача.

UPDATE users SET email = 'newemail@example.com' WHERE id = 1;

4. Delete (Видалення):

 Операція, яка дозволяє видаляти записи з бази даних.

 Це зазвичай відбувається через SQL-запит DELETE.

 Приклад: Видалення користувача з бази даних.

DELETE FROM users WHERE id = 1;

Важливість CRUD: CRUD є  базовим  принципом  для  взаємодії  з  базами  даних, оскільки  більшість  додатків  потребує  виконання  цих  операцій  для  зберігання  та  маніпуляції  даними. Наприклад: Вебсайти та веб-додатки часто використовують CRUD-операції для керування користувачами, товарами, замовленнями тощо. Багато бібліотек і фреймворків розроблені так, щоб полегшити використання цих операцій, зокрема за допомогою ORM (Object-Relational Mapping) інструментів.

## **Як працює ORM?**

**ORM (Object-Relational Mapping)**--- це  технологія, яка  дозволяє  програмістам  працювати  з  базами  даних, використовуючи  об'єктно-орієнтовану  модель  даних  замість  безпосереднього  написання SQL-запитів. ORM дозволяє з'єднати об'єкти програми (наприклад, класи в об'єктно-орієнтованих мовах програмування) з таблицями в реляційній базі даних.

ORM автоматично генерує SQL-запити на основі операцій над об'єктами програми. Це дозволяє програмістам працювати з базою даних через об'єкти та їх атрибути, замість того, щоб писати SQL-код вручну. ORM керує перетворенням даних між об'єктами і таблицями бази даних, забезпечуючи прозорість і зручність роботи з даними.

Основні принципи роботи ORM:

1. Маппінг: Класи програми (зазвичай у вигляді об'єктів) мапуються на таблиці в базі даних. Поля класів (атрибути) мапуються на стовпці таблиць бази даних.

2. Автоматичне генерування SQL: Коли ви виконуєте операції з об'єктами (створення, читання, оновлення, видалення --- CRUD), ORM автоматично генерує необхідні SQL-запити для виконання цих операцій на базі даних.

3. Інкапсуляція взаємодії з базою даних: ORM дозволяє уникнути написання прямого SQL-коду, а також може включати механізми кешування, підвищення ефективності та управління транзакціями.

Переваги використання ORM:

1. Зручність: Програмісти можуть працювати з об'єктами, що значно простіше, ніж писати SQL-запити вручну.

2. Підвищення продуктивності: ORM часто автоматизує багато рутинних операцій, таких як перевірка правильності даних і обробка транзакцій.

3. Перехресна платформа: ORM-фреймворки часто підтримують роботу з різними СУБД (MySQL, PostgreSQL, SQLite, Oracle тощо), що дозволяє зменшити залежність від конкретної технології.

4. Читабельність коду: Код, який працює з базою даних, зазвичай виглядає чисто і зручно, оскільки все відбувається через об'єкти.

Недоліки ORM:

1. Продуктивність: Іноді використання ORM може призвести до неефективних SQL-запитів, особливо при складних операціях з великими обсягами даних.

2. Обмеження: Хоча ORM дозволяє працювати з базами даних на високому рівні, інколи доступ до специфічних функцій СУБД може бути обмежений або складний через абстракцію.

3. Навчання: Програмістам може знадобитися час на вивчення специфічного ORM-фреймворка, особливо якщо він містить складну логіку або функціональність.

Приклад використання ORM (Python, SQLAlchemy):

from sqlalchemy import create_engine, Column, Integer, String

from sqlalchemy.ext.declarative import declarative_base

from sqlalchemy.orm import sessionmaker

# Створення  базового  класу  для  моделей

Base = declarative_base()

# Створення  моделі, яка  відповідає  таблиці  в  базі  даних

class User(Base):

 __tablename__ = 'users'

 id = Column(Integer, primary_key=True)

 name = Column(String)

 email = Column(String)

# Підключення  до  бази  даних

engine = create_engine('sqlite:///users.db')

Base.metadata.create_all(engine)

# Створення  сесії  для  виконання  запитів

Session = sessionmaker(bind=engine)

session = Session()

# Створення  нового  користувача

new_user = User(name="John Doe", email="johndoe@example.com")

# Додавання користувача до бази даних

session.add(new_user)

session.commit()

# Запит на отримання всіх користувачів

users = session.query(User).all()

for user in users:

 print(user.name, user.email)

session.close()

У цьому прикладі:

-   Клас User є об'єктом, який відповідає таблиці users в базі даних.
-   ORM (в даному випадку, SQLAlchemy) автоматично генерує SQL-запити для створення таблиці, вставки даних та виконання запитів до бази.

Популярні ORM:

1. SQLAlchemy --- для Python.

2. Hibernate --- для Java.

3. Django ORM --- для Python (в рамках фреймворку Django).

4. Entity Framework --- для .NET.

5. ActiveRecord --- для Ruby on Rails.

Висновок:

ORM значно полегшує роботу з базами даних, оскільки програмісти можуть маніпулювати об'єктами, замість того щоб писати SQL-запити вручну. Однак важливо знати, коли доцільно використовувати ORM, а коли варто використовувати чисті SQL-запити для більшої ефективності або контролю.

## **For what purposes manage.py is used?**

manage.py --- це  скрипт, який  є  частиною  проектів, створених  з  використанням  фреймворку Django для  розробки  веб-додатків  на Python. Він виконує роль інтерфейсу для керування різними аспектами вашого проекту та взаємодії з Django-проектом через командний рядок.

Основні функції manage.py:

1. Запуск серверу розробки: За допомогою manage.py можна швидко запустити сервер для локальної розробки, щоб тестувати веб-додаток.

python manage.py runserver

Це запускає сервер, на якому можна переглядати і тестувати ваш додаток.

2. Міграції бази даних: Django використовує міграції для управління змінами в структурі бази даних. manage.py дозволяє створювати, застосовувати та відкатувати міграції.

o Створення міграцій:

python manage.py makemigrations

Це генерує нові файли міграцій для змін в моделях бази даних.

o Застосування міграцій:

python manage.py migrate

Це застосовує міграції та оновлює структуру бази даних відповідно до змін моделей.

3. Створення суперкористувача: Для адміністрування сайту в Django часто потрібно створити суперкористувача, який матиме доступ до адмін-панелі.

python manage.py createsuperuser

Ця команда допоможе створити обліковий запис суперкористувача для доступу до адміністративного інтерфейсу.

4. Тестування: manage.py також дозволяє запускати тести для перевірки правильності роботи вашого додатку.

python manage.py test

Це запускає тестування всіх ваших модулів та моделей, що допомагає виявити помилки і недоліки в коді.

5. Збір статичних файлів: Для публікації веб-додатку в продакшн-середовищі Django дозволяє збирати всі статичні файли (CSS, JavaScript, зображення тощо) в одну папку для ефективного використання.

python  manage.py  collectstatic

Ця команда копіює статичні файли у вказану директорію, що дозволяє зручно працювати з ними на сервері.

6. Запуск команд адміністратора: Django надає можливість створювати свої власні команди, що можна виконувати через manage.py. Ви можете створювати власні функції для обробки специфічних завдань, таких як імпорт даних, очищення бази даних або виконання певних обчислень.

7. Перевірка стану проекту: Django також має вбудовані команди для перевірки стану проекту, наприклад:

python manage.py check

Це перевіряє ваш проект на наявність потенційних проблем або помилок конфігурації.

Загальний  вигляд  команди:

python manage.py <command> [options]

Приклад:

python manage.py runserver 8000

Ця команда запускає сервер на порту 8000.

Підсумок:

manage.py --- це універсальний інструмент для керування проектом Django, який дозволяє виконувати різні завдання, пов'язані з розробкою та адмініструванням веб-додатка. Це зручний спосіб інтегрувати різні команди для управління проектом, зокрема запуск серверу, виконання міграцій, тестування, створення суперкористувачів і багато іншого.

Якщо ви працюєте з Django, то manage.py стане вашим основним інструментом для взаємодії з проектом через командний рядок.

## **settings.py**?

**settings**.py у проекті Django містить конфігураційні налаштування, які визначають, як працює ваш проект. Це важливий файл, що забезпечує налаштування різних аспектів функціонування веб-додатку, від бази даних до безпеки, серверу, файлів статичних ресурсів та багатьох інших параметрів.

Основні розділи та налаштування в settings.py:

1. Основні налаштування:

o DEBUG: Параметр, що визначає, чи знаходиться проект у режимі розробки. У режимі розробки (коли DEBUG=True) будуть виводитися детальні помилки. В продакшн-режимі слід встановити DEBUG=False, щоб не надавати чутливу інформацію.

DEBUG = True

o SECRET_KEY: Таємний ключ, який використовується для криптографічного підпису даних, наприклад, сесій або паролів. Цей ключ повинен бути секретним і не потрапляти у публічні репозиторії.

SECRET_KEY = 'your-secret-key'

o ALLOWED_HOSTS: Список дозволених хостів або доменів, які можуть доступати ваш додаток. Це необхідно для захисту від атак на заголовки HTTP Host.

ALLOWED_HOSTS = ['example.com', 'www.example.com']

2. Встановлені додатки (INSTALLED_APPS):

o INSTALLED_APPS: Список додатків, які є частиною вашого проекту Django. Це можуть бути як стандартні додатки Django (наприклад, django.contrib.admin), так і ваші власні додатки.

INSTALLED_APPS = [

 'django.contrib.admin',

 'django.contrib.auth',

 'django.contrib.contenttypes',

 'myapp',

# інші  додатки

]

3. Налаштування бази даних:

o DATABASES: Налаштування для підключення до бази даних. Django за замовчуванням використовує SQLite, але ви можете налаштувати підключення до інших СУБД, таких як PostgreSQL, MySQL тощо.

DATABASES = {

 'default': {

 'ENGINE': 'django.db.backends.sqlite3',

 'NAME': BASE_DIR / 'db.sqlite3',

 }

}

4. Статичні файли та медіа:

o STATIC_URL та STATICFILES_DIRS: Налаштування для керування статичними файлами (CSS, JavaScript, зображення), які використовуються в проекті.

STATIC_URL = '/static/'

STATICFILES_DIRS = [BASE_DIR / 'static']

o MEDIA_URL та MEDIA_ROOT: Налаштування  для  зберігання  медіа-файлів (файли, завантажені  користувачами).

MEDIA_URL = '/media/'

MEDIA_ROOT = BASE_DIR / 'media'

5. Безпека:

o SECURE_SSL_REDIRECT: Якщо встановити в True, Django автоматично перенаправить всі HTTP-запити на HTTPS.

SECURE_SSL_REDIRECT = True

o CSRF_COOKIE_SECURE та SESSION_COOKIE_SECURE: Це  налаштування  забезпечують, що  файли cookie будуть  передаватися  тільки  через HTTPS.

CSRF_COOKIE_SECURE = True

SESSION_COOKIE_SECURE = True

6. Міжнародні налаштування:

o LANGUAGE_CODE та TIME_ZONE: Налаштування мови та часового поясу для вашого додатку.

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

7. Налаштування електронної пошти:

o EMAIL_BACKEND: Налаштування для відправки електронних листів. В продакшн-середовищі часто використовують SMTP-сервер для відправки листів.

EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'

EMAIL_HOST = 'smtp.example.com'

EMAIL_PORT = 587

EMAIL_USE_TLS = True

EMAIL_HOST_USER = 'your_email@example.com'

EMAIL_HOST_PASSWORD = 'your_password'

8. Проміжне програмне забезпечення (Middleware):

o MIDDLEWARE: Це список проміжного програмного забезпечення, яке обробляє запити та відповіді в Django. Включає механізми аутентифікації, обробки сесій, безпеки та ін.

MIDDLEWARE = [

 'django.middleware.security.SecurityMiddleware',

 'django.contrib.sessions.middleware.SessionMiddleware',

 'django.middleware.common.CommonMiddleware',

# інші middleware

]

9. Налаштування кешування:

o Django підтримує кешування для покращення продуктивності. В settings.py можна налаштувати систему кешування.

CACHES = {

 'default': {

 'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',

 'LOCATION': '127.0.0.1:11211',

 }

}

10. Налаштування сесій:

o SESSION_ENGINE: Визначає механізм для управління сесіями. За замовчуванням використовується сесія в базі даних.

SESSION_ENGINE = 'django.contrib.sessions.backends.db'

Підсумок: settings.py --- це  важливий  файл  конфігурації  вашого  проекту Django, який  містить  основні  налаштування  для  роботи  з  базою  даних, статичними  та  медіа-файлами, безпекою, аутентифікацією, електронною  поштою  та  іншими  важливими  аспектами  веб-додатку.

Ці налаштування можна легко змінювати залежно від потреб вашого проекту, наприклад, при переході з розробки до продакшн-середовища.

## **Моделі (models)**?

Моделі (models) у Django --- це механізм для визначення структури бази даних вашого веб-додатку. Вони представляють собою Python-класи, що відповідають таблицям у базі даних, де кожен атрибут класу є полем таблиці. Django автоматично генерує SQL-код для створення, зміни або оновлення таблиць у базі даних на основі ваших моделей.

Основні моменти про моделі в Django:

1. Клас моделі: Кожна модель у Django є класом, який успадковує від класу django.db.models.Model. Це дозволяє Django автоматично створювати відповідні таблиці в базі даних, а також забезпечує механізм для роботи з даними через Python-об'єкти.

Приклад простого класу моделі:

from  django.db  import  models

class Person(models.Model):

name = models.CharField(max_length=100) # Поле  для  збереження  імені

age = models.IntegerField() # Поле  для  збереження  віку

email = models.EmailField() # Поле  для  збереження  електронної  пошти

 def __str__(self):

 return self.name

У  цьому  прикладі  клас Person є  моделлю, яка  має  три  поля: name, age та email.

2. Поля  моделей: В Django існує  багато  різних  типів  полів, які  відповідають  різним  типам  даних  у  базах  даних. Ось деякі з них:

o CharField: для зберігання текстових даних (наприклад, імен, адрес).

o IntegerField: для зберігання цілих чисел.

o EmailField: для зберігання електронних адрес.

o DateTimeField: для зберігання дат і часу.

o BooleanField: для зберігання булевих значень (True/False).

o ForeignKey: для встановлення зв'язків між таблицями (відношення "один до багатьох").

o ManyToManyField: для багатьох зв'язків між таблицями (відношення "багато до багатьох").

o OneToOneField: для створення зв'язку "один до одного".

3. Міграції (Migrations): Моделі в Django використовуються для створення міграцій --- скриптів для оновлення бази даних, що дозволяє автоматично створювати таблиці, додавати або змінювати поля. Міграції створюються за допомогою команд:

o Створення міграцій для моделей:

python manage.py makemigrations

o Застосування міграцій для створення/оновлення таблиць:

python manage.py migrate

4. Запити до бази даних через моделі: Після того як ви створили моделі, Django дозволяє вам легко працювати з даними через API моделей, без необхідності писати SQL-запити вручну. Ви можете створювати, зберігати, оновлювати та видаляти записи в базі даних за допомогою стандартних Python-операцій.

Наприклад:

o Створення нового об'єкта:

person = Person(name="John Doe", age=30, email="john.doe@example.com")

person.save() # Зберігає  об'єкт  у  базі  даних

o Отримання об'єктів з бази даних:

person = Person.objects.get(id=1) # Отримання  об'єкта  з id=1

o Фільтрація та пошук:

young_people = Person.objects.filter(age__lt=30) # Всі  особи  віком  менше 30 років

o Оновлення об'єкта:

person.age = 31

person.save() # Оновлює запис у базі даних

o Видалення об'єкта:

person.delete() # Видаляє об'єкт з бази даних

5. Методи та відношення між моделями: Django дозволяє створювати зв'язки між моделями через різні типи полів, такі як ForeignKey, OneToOneField та ManyToManyField.

Наприклад, якщо ми хочемо зв'язати модель Person з моделлю Book (кожна особа може мати багато книг), ми можемо використати ForeignKey:

class Book(models.Model):

 title = models.CharField(max_length=100)

 person = models.ForeignKey(Person, on_delete=models.CASCADE)

Підсумок: Моделі в Django є основним інструментом для взаємодії з базою даних. Вони визначають структуру таблиць, а також забезпечують простий інтерфейс для роботи з даними. Ви можете визначати різні типи полів, встановлювати зв'язки між таблицями і виконувати операції з базою даних через об'єкти моделей, що робить Django зручним для розробки веб-додатків.

## **Що таке migrations?**

**Міграції (migrations) в Django **--- це система для керування змінами в структурі бази даних протягом розвитку проекту. Вони дозволяють автоматично створювати та застосовувати зміни в базі даних на основі змін у моделях (Python-класах). Міграції забезпечують зручний спосіб підтримки бази даних у відповідності до змін у коді вашого додатку, зокрема моделей.

Як працюють міграції в Django?

1. Міграції базуються на моделях: Кожна модель, яку ви створюєте в Django, описує структуру таблиці в базі даних. Коли ви змінюєте модель (наприклад, додаєте нове поле або змінюєте тип даних поля), Django використовує систему міграцій для створення SQL-запитів, які оновлять структуру бази даних відповідно до змін.

2. Основні команди для роботи з міграціями:

o Створення міграцій: Коли ви змінюєте моделі, Django дозволяє створювати міграції, що описують ці зміни. Це робиться через команду:

python manage.py makemigrations

Ця команда генерує нові файли міграцій, які містять інструкції для внесення змін у базу даних (наприклад, створення нової таблиці або додавання поля до існуючої таблиці).

o Застосування міграцій: Після того, як ви створили міграції, вам потрібно застосувати їх до бази даних. Це робиться за допомогою команди:

python manage.py migrate

Ця команда застосує всі невиконані міграції, оновлюючи структуру бази даних.

o Список міграцій: Щоб побачити всі міграції, які були застосовані або залишаються для застосування, можна використати команду:

python manage.py showmigrations

o Скасування міграції: Якщо ви хочете скасувати останню міграцію, можна використати:

python manage.py migrate <app_name> <migration_name>

Це поверне базу даних до певного стану, визначеного міграцією.

3. Формат міграцій: Міграції є Python-скриптами, згенерованими Django. Вони знаходяться в кожному додатку проекту в каталозі migrations/ і зазвичай мають назви на зразок 0001_initial.py, 0002_auto_20250210_1035.py тощо.

Приклад вмісту міграційного файлу:

# Generated by Django 3.x on 2025-02-10 10:35

from django.db import migrations, models

class Migration(migrations.Migration):

 dependencies = [

 ('myapp', '0001_initial'),

 ]

 operations = [

 migrations.AddField(

 model_name='person',

 name='phone',

 field=models.CharField(max_length=15, null=True, blank=True),

 ),

 ]

В цьому прикладі, міграція додає нове поле phone до моделі Person.

4. Автоматичні міграції: Django може автоматично генерувати міграції для нових моделей і змін в існуючих моделях. Однак для більш складних змін інколи потрібно вручну редагувати міграції, особливо якщо зміни включають в себе кастомні операції або певні налаштування бази даних.

5. Залежності між міграціями: Міграції можуть мати залежності від інших міграцій, які вже були застосовані. Це дозволяє Django правильно застосовувати зміни в правильному порядку, якщо в проекті є кілька додатків або складні зміни в базі даних.

6. Зворотні міграції: Django дозволяє скасовувати зміни, застосовуючи зворотні міграції:

python manage.py migrate <app_name> zero

Це відкотить всі міграції для зазначеного додатка, повертаючи базу даних до початкового стану.

Підсумок:

Міграції в Django --- це система для автоматичного керування змінами в базі даних. Вони дозволяють безпечно і зручно оновлювати базу даних, застосовуючи зміни, визначені в моделях, без необхідності писати SQL-запити вручну. Використовуючи команду makemigrations, ви генеруєте міграції, а командою migrate їх застосовуєте.

Це потужний інструмент для збереження консистентності бази даних і забезпечення безпечних змін у розробці проекту.

## **QuerySet**** в ****Django**?

QuerySet в Django --- це колекція об'єктів, які отримані з бази даних за допомогою моделей Django. По суті, QuerySet є результатом запиту до бази даних, який дозволяє вам працювати з даними, не написавши жодного SQL-запиту вручну.

Основні поняття про QuerySet в Django:

1. Що таке QuerySet? QuerySet в Django --- це абстракція над SQL-запитом. Коли ви викликаєте методи на моделі, щоб отримати дані з бази даних, Django формує відповідний SQL-запит і повертає QuerySet, який містить ці дані. QuerySet --- це, по суті, список (або набір) об'єктів моделі, який може бути додатково відфільтрований, відсортований або обмежений за кількістю.

2. Приклад використання QuerySet: Припустимо, у вас є модель Person:

class Person(models.Model):

name = models.CharField(max_length=100)

 age = models.IntegerField()

Для отримання всіх осіб з бази даних можна використати наступний код:

people = Person.objects.all() # Отримуємо всі записи з таблиці Person

Це повертає QuerySet, який містить усіх осіб з бази даних.

3. Фільтрація QuerySet: QuerySet дозволяє вам застосовувати фільтри для вибірки конкретних записів з бази даних. Наприклад, для отримання всіх осіб, вік яких більше 30 років, можна застосувати метод filter:

people = Person.objects.filter(age__gt=30) # Отримуємо осіб старших за 30 років

У даному випадку метод filter повертає QuerySet з усіма особами, вік яких більше 30 років.

4. Методи для роботи з QuerySet:

o all(): Повертає всі записи в таблиці.

people = Person.objects.all()

o filter(): Фільтрує записи за умовами.

young_people = Person.objects.filter(age__lt=30) # Всі  особи  віком  менше 30 років

o get(): Повертає один об'єкт за умовою. Викликається, коли ви точно знаєте, що запит поверне лише один запис.

person = Person.objects.get(id=1) # Повертає  особу  з id = 1

o exclude(): Повертає всі записи, що не відповідають умові.

not_young_people = Person.objects.exclude(age__lt=30) # Всі, хто  старше  або  рівно 30 років

o order_by(): Сортує записи за певним полем.

people = Person.objects.all().order_by('age') # Сортуємо  за  віком (за  зростанням)

o distinct(): Повертає лише унікальні записи.

unique_people = Person.objects.all().distinct()

o count(): Підраховує  кількість  записів  у QuerySet.

total_people = Person.objects.count() # Підраховує  загальну  кількість  людей

o first() / last(): Повертає  перший  або  останній  об'єкт  у QuerySet.

first_person = Person.objects.first() # Перший  запис

last_person = Person.objects.last() # Останній  запис

5. Лінійка  запитів (Chaining):  Один  з  основних  принципів  роботи  з QuerySet в Django --- це  можливість  ланцюгового  виклику  методів. Ви можете комбінувати методи фільтрації, сортування, обмеження та інші, щоб отримати потрібний результат.

Наприклад:

people = Person.objects.filter(age__gt=30).order_by('name').exclude(name='John')

Цей запит поверне осіб старших за 30 років, відсортованих за іменем, але без осіб на ім'я "John".

6. Lazy Evaluation (Лінивий запит): QuerySet в Django має лінивий характер, що означає, що запит до бази даних не виконується доти, поки ви не почнете ітерувати або обробляти результати. Це дозволяє оптимізувати виконання запитів. Наприклад:

people = Person.objects.filter(age__gt=30)

# Запит не виконується, поки ми не ітеруємо через QuerySet:

for person in people:

print(person.name)

7. Агрегування даних: Django дозволяє використовувати функції агрегації для обчислення статистики або виконання математичних операцій над даними:

o aggregate(): Використовується для виконання агрегатних операцій (наприклад, сум, середніх значень).

from django.db.models import Avg, Max, Min, Sum

result = Person.objects.aggregate(Avg('age'))

8. Prefetching і Select Related: Якщо у вас є зв'язки між моделями, ви можете використовувати методи select_related або prefetch_related для  оптимізації  запитів, зменшуючи  кількість  звернень  до  бази  даних.

o select_related: Використовується для оптимізації запитів при відношенні "один до багатьох" або "один до одного".

people = Person.objects.select_related('related_model').all()

o prefetch_related: Використовується для "багато до багатьох" або для отримання зв'язків з іншими моделями.

people = Person.objects.prefetch_related('related_model_set').all()

Підсумок:

QuerySet в Django --- це інструмент для роботи з базою даних. Він дозволяє формувати складні запити без написання SQL, а також обробляти отримані  дані  через Python-методи, забезпечуючи  при  цьому  високу  гнучкість  і  зручність. Ви можете фільтрувати, сортувати, агрегувати дані та виконувати багато інших операцій, щоб отримати потрібну інформацію з бази даних.

## **Які різні поля в Django ORM ви знаєте (перелічіть усі)?Which different fields in Django ORM you know (list all of them)?**

Django ORM (Object-Relational Mapping) надає різноманітні типи полів для визначення структури бази даних. Ось список основних полів, які можна використовувати в Django моделях:

1. **CharField** -- для збереження коротких рядків, зазвичай використовується для текстових значень з обмеженням довжини.

2. **TextField** -- для збереження довгих текстів (без обмеження довжини).

3. **IntegerField** -- для збереження цілих чисел.

4. **FloatField** -- для збереження чисел з плаваючою комою.

5. **DecimalField** -- для збереження десяткових чисел з точністю.

6. **BooleanField** -- для збереження значень True/False.

7. **DateField** -- для збереження дати (без часу).

8. **TimeField** -- для збереження часу (без дати).

9. **DateTimeField** -- для збереження дати та часу.

10. **DurationField** -- для збереження тривалості часу (наприклад, у форматі: годин, хвилин, секунд).

11. **EmailField** -- для збереження електронних адрес.

12. **URLField** -- для збереження URL-адрес.

13. **FileField** -- для збереження файлів (якщо потрібно зберігати файли, то можна додатково вказати шлях до зберігання).

14. **ImageField** -- для збереження зображень (це підклас FileField, що додатково перевіряє, чи є файл зображенням).

15. **IPAddressField** -- для збереження IP-адрес.

16. **SlugField** -- для збереження зручних для URL текстових рядків (звичайно використовується в ссилках).

17. **UUIDField** -- для збереження унікальних ідентифікаторів (UUID).

18. **ForeignKey** -- для створення зв'язку "багато до одного" між моделями.

19. **OneToOneField** -- для створення зв'язку "один до одного" між моделями.

20. **ManyToManyField** -- для створення зв'язку "багато до багатьох" між моделями.

21. **JSONField** -- для збереження даних у форматі JSON (підтримка залежить від версії Django та бази даних).

22. **ArrayField** -- для збереження масивів (працює з PostgreSQL).

23. **NullBooleanField** (deprecated) -- для збереження трьох станів: True, False або None (потрібно використовувати BooleanField з параметром null=True).

24. **BinaryField** -- для збереження бінарних даних (наприклад, файлів або інших даних в бінарному форматі).

Ці поля дозволяють створювати гнучкі та моделі для взаємодії з базою даних у Django.

## **Яка різниця між null і blank?****What is the difference between null and blank?**

У Django, параметри null та blank використовуються для визначення того, як поля мають поводитись з порожніми значеннями. Хоча вони здаються схожими, їхня роль різна.

**1\. null Визначає, чи дозволяється полю мати NULL значення в базі даних.**

-   Коли null=True, це означає, що поле може бути порожнім на рівні бази даних, тобто у відповідній колонці в базі даних буде зберігатися значення NULL (якщо дане поле не заповнене).
-   Це зазвичай використовується для полів, які можуть бути порожніми в базі даних, наприклад, для числових або датових полів.

**Приклад****:**birth_date = models.DateField(null=True)

Тут поле birth_date може містити NULL значення в базі даних, якщо користувач не заповнить його.

**2\. blank Визначає, чи дозволяється полю бути порожнім у формах Django.**

-   Коли blank=True, це означає, що поле не є обов'язковим при валідації форм. Якщо це поле не буде заповнене в формі, воно буде вважатися допустимим (не буде генерувати помилку).
-   Використовується для контролю поведінки полів під час роботи з формами (наприклад, при заповненні через адмінку чи інтерфейс).

**Приклад****: **middle_name = models.CharField(max_length=100, blank=True)

Тут поле middle_name не є обов'язковим в формах, тобто користувач може залишити його порожнім при заповненні форми.

**Різниця між null і blank:**

-   **null** визначає, чи дозволяється зберігати значення NULL в базі даних (це працює на рівні бази даних).
-   **blank** визначає, чи дозволяється залишати поле порожнім у формах Django (це працює на рівні валідації форм).

**Комбінація null і blank**

Іноді ви можете використовувати обидва параметри разом:

-   Якщо ви хочете, щоб поле могло бути порожнім як в базі даних, так і в формах, вам слід встановити обидва параметри:

phone_number = models.CharField(max_length=15, null=True, blank=True)

**Зауваження:**

-   Для **текстових полів** (CharField, TextField) зазвичай використовують blank=True, але не використовують null=True, оскільки Django вважає порожній рядок "" таким же, як і відсутність значення. Тому для текстових полів зазвичай використовують blank=True замість null=True.
-   Для **числових** полів (IntegerField, FloatField тощо) часто використовують null=True, оскільки ці типи можуть мати відсутнє значення, що буде представлено як NULL в базі даних.

У підсумку: **null** --- працює на рівні бази даних. **blank** --- працює на рівні форм.

## **Що таке field choices**?

У Django, параметр choices використовується для обмеження можливих значень поля, дозволяючи вибирати лише зі списку попередньо визначених варіантів. Це дозволяє забезпечити консистентність даних та полегшити взаємодію з користувачем, наприклад, через форми або адміністративний інтерфейс.

Як працює choices?

Коли ви використовуєте choices, ви визначаєте список кортежів, де кожен кортеж містить два елементи:

1. Значення, яке зберігається в базі даних.

2. Мітка (або відображене значення), яке відображається користувачу (наприклад, у формі чи в адмінці).

Приклад використання choices

Уявімо, що у вас є модель, і ви хочете створити поле для вибору статусу замовлення, де статус може бути "новий", "обробляється" або "завершено".

from django.db import models

class Order(models.Model):

# визначаємо  можливі  варіанти  статусів

 ORDER_STATUS_CHOICES = [

 ('new', 'New'),

 ('processing', 'Processing'),

 ('completed', 'Completed'),

 ]

 status = models.CharField(

 max_length=10,

 choices=ORDER_STATUS_CHOICES,

 default='new'

 )

У цьому прикладі:

-   Поле status буде зберігати одне з цих значень: 'new', 'processing', або 'completed'.
-   Однак у формі або в адмінці користувач побачить відображені значення, такі як "New", "Processing", або "Completed".

Деталі:

-   max_length має бути достатньо великим, щоб вмістити значення з кортежу, наприклад, 10 символів для статусів.
-   choices --- це список або кортеж, який містить пари (значення в базі даних, відображене значення).
-   default --- вказує значення за замовчуванням, яке буде використовуватись, якщо користувач не вибере нічого.

Відображення в адмінці:

У Django адмінці поле зі choices буде відображатися як випадаючий список з варіантами, що дозволяє користувачам вибирати з попередньо визначених варіантів.

Як використовувати в коді:

Для роботи з полем можна використовувати значення, визначене в choices, або звертатися до нього через його метки.

# Задати статус через значення

order = Order.objects.create(status='new')

# Перевірка  статусу

if order.status == 'new':

 print("The order is new!")

# Переведення  статусу  в  людське  читання

status_label = dict(Order.ORDER_STATUS_CHOICES).get(order.status)

print(status_label) # "New"

Статичні  методи  для  зручності

В Django можна створити методи в моделі, щоб зручніше працювати з choices.

class Order(models.Model):

 ORDER_STATUS_CHOICES = [

 ('new', 'New'),

 ('processing', 'Processing'),

 ('completed', 'Completed'),

 ]

 status = models.CharField(

 max_length=10,

 choices=ORDER_STATUS_CHOICES,

 default='new'

 )

 def get_status_display(self):

 return dict(self.ORDER_STATUS_CHOICES).get(self.status)

Тепер можна викликати метод get_status_display() для отримання людського вигляду значення поля:

order = Order.objects.get(id=1)

print(order.get_status_display()) # "New"

Переваги використання choices:

1. Обмеження вибору: гарантує, що значення поля будуть лише в межах визначених варіантів.

2. Зрозумілість для користувачів: замість числових кодів або абстрактних значень ви надаєте користувачам зрозумілі мітки.

3. Легкість у використанні в формах та адмінці: Django автоматично відобразить ці варіанти як випадаючий список.

Висновок:

choices --- це зручний механізм для обмеження варіантів значення поля в Django, що допомагає забезпечити чіткість та цілісність даних, а також полегшує взаємодію з користувачем.

## **Які****відносини****ви****знаєте****.? What kind of relations you know?**

У **Django ORM**є  три  основні  типи  відносин  між  моделями, які  дозволяють  створювати  зв'язки  між  таблицями  в  базі  даних. Це важливо для нормалізації структури даних та забезпечення зручності взаємодії з ними. Ось основні відносини:

1\. **One-to-Many** (Один до багатьох)

-   **ForeignKey** --- це тип відносин "один до багатьох".
-   Один об'єкт з однієї моделі може бути пов'язаний з багатьма об'єктами з іншої моделі.
-   Це найпоширеніший тип відносин. Наприклад, один автор може мати багато книг.

Приклад:

class Author(models.Model):

 name = models.CharField(max_length=100)

class Book(models.Model):

 title = models.CharField(max_length=200)

 author = models.ForeignKey(Author, on_delete=models.CASCADE)

У цьому прикладі:

-   Кожна книга (Book) має лише одного автора (Author).
-   Автор може мати багато книг.

2\. **One-to-One** (Один до одного)

-   OneToOneField --- це відносини "один до одного".
-   Один об'єкт з однієї моделі може бути пов'язаний лише з одним об'єктом з іншої моделі, і навпаки.
-   Це корисно для додаткових даних, що мають бути збережені для одного конкретного об'єкта. Наприклад, кожен користувач може мати лише один профіль.

Приклад:

class User(models.Model):

 username = models.CharField(max_length=100)

class Profile(models.Model):

 user = models.OneToOneField(User, on_delete=models.CASCADE)

 bio = models.TextField()

У  цьому  прикладі:

-   Кожен користувач має тільки один профіль.
-   Кожен профіль належить лише одному користувачу.

3\. **Many-to-Many** (Багато  до  багатьох)

-   ManyToManyField --- це  відносини "багато  до  багатьох".
-   Один  об'єкт  з  однієї  моделі  може  бути  пов'язаний  з  багатьма  об'єктами  з  іншої  моделі, і  навпаки.
-   Це часто використовується для ситуацій, коли багато об'єктів можуть бути пов'язані з іншими об'єктами в обох напрямках. Наприклад, багато студентів можуть записуватись на багато курсів.

Приклад:

class Student(models.Model):

 name = models.CharField(max_length=100)

class Course(models.Model):

 title = models.CharField(max_length=200)

 students = models.ManyToManyField(Student)

У  цьому  прикладі:

-   Кожен студент може бути записаний на багато курсів.
-   Кожен курс може мати багато студентів.

Параметри для налаштування відносин:

У кожному з цих типів відносин є параметри, які можна налаштувати, наприклад:

-   on_delete --- що відбувається з об'єктами, коли об'єкт, до якого вони прив'язані, видаляється.

-   models.CASCADE: якщо пов'язаний об'єкт видалено, то всі пов'язані об'єкти також видаляються.
-   models.PROTECT: не дозволяє видаляти об'єкт, якщо до нього є пов'язані записи.
-   models.SET_NULL: встановлює значення NULL у зв'язаному полі, якщо об'єкт видаляється.
-   models.SET_DEFAULT: встановлює значення за замовчуванням для зв'язаного поля, якщо об'єкт видаляється.

-   related_name --- задає ім'я для зворотного зв'язку з іншої моделі. Наприклад, замість того, щоб використовувати стандартне ім'я book_set, можна визначити власне ім'я для зворотного зв'язку.

Приклад:

class Author(models.Model):

 name = models.CharField(max_length=100)

class Book(models.Model):

 title = models.CharField(max_length=200)

 author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name='books')

Тепер можна отримати всі книги автора, використовуючи author.books.all().

Підсумок:

-   **One-to-Many** (Один до багатьох): використовує ForeignKey.
-   **One-to-One** (Один до одного): використовує OneToOneField.
-   **Many-to-Many** (Багато  до  багатьох): використовує ManyToManyField.

Ці відносини дозволяють вам створювати складні структури баз даних і працювати з ними через Django ORM у зручний спосіб.

## **Що означають різні параметри on_delete?**

У Django параметр on_delete визначає, що робити з об'єктами, які мають зв'язок (наприклад, через ForeignKey, OneToOneField або ManyToManyField), коли об'єкт, до якого вони прив'язані, видаляється. Це важливий аспект, оскільки може бути необхідно налаштувати поведінку залежно від ваших вимог до цілісності даних.

Ось різні значення для on_delete та їхнє значення:

1\. models.CASCADE

-   Означає: Якщо об'єкт, до якого є зв'язок, видаляється, всі пов'язані об'єкти також будуть видалені.
-   Приклад: Якщо видаляється автор, то всі його книги будуть автоматично видалені.

Приклад  використання:

author = models.ForeignKey(Author, on_delete=models.CASCADE)

2\. models.PROTECT

-   Означає: Якщо об'єкт, до якого є зв'язок, намагаються видалити, це призведе до виключення помилки ProtectedError (Django не дозволить видалити об'єкт, якщо є зв'язані з ним об'єкти).
-   Приклад: Якщо намагаються видалити автора, який має книги, Django згенерує помилку, і видалення не відбудеться.

Приклад  використання:

author = models.ForeignKey(Author, on_delete=models.PROTECT)

3\. models.SET_NULL

-   Означає: Якщо об'єкт, до якого є зв'язок, видаляється, значення цього поля у всіх зв'язаних об'єктах буде встановлено в NULL. Цей параметр працює тільки в тому випадку, якщо поле дозволяє зберігати значення NULL (тобто якщо ви використовуєте null=True).
-   Приклад: Якщо автор видалений, то книги, пов'язані з ним, більше не матимуть автора (поле author стане NULL).

Приклад  використання:

author = models.ForeignKey(Author, on_delete=models.SET_NULL, null=True)

4\. models.SET_DEFAULT

-   Означає: Якщо об'єкт, до якого є зв'язок, видаляється, значення цього поля буде встановлено на значення за замовчуванням.
-   Приклад: Якщо автор видаляється, то всі книги, пов'язані з ним, будуть автоматично оновлені і матимуть значення за замовчуванням для автора.

Приклад  використання:

author = models.ForeignKey(Author, on_delete=models.SET_DEFAULT, default=default_author)

5\. models.SET()

-   Означає: Якщо об'єкт, до якого є зв'язок, видаляється, це поле буде встановлено на значення, яке передається в функцію SET(). Ви можете передати будь-яку функцію, яка повертає значення для цього поля.
-   Приклад: Ви можете створити функцію, яка буде встановлювати певне значення, якщо пов'язаний об'єкт видаляється.

Приклад використання:

def set_default_author():

 return Author.objects.get(name='Default Author')

author = models.ForeignKey(Author, on_delete=models.SET(set_default_author))

6\. models.DO_NOTHING

-   Означає: Не вживається жодних дій, коли об'єкт видаляється. Ви повинні самі вирішити, як обробляти цей випадок. Це може бути корисно, якщо ви хочете реалізувати власну логіку або використовувати тригери бази даних.
-   Приклад: Django не буде змінювати пов'язані об'єкти, тому вам потрібно самому написати код для обробки цього випадку (наприклад, в сигналах).

Приклад  використання:

author = models.ForeignKey(Author, on_delete=models.DO_NOTHING)

Резюме:

1. models.CASCADE -- видаляє пов'язані об'єкти.

2. models.PROTECT -- не дозволяє видаляти об'єкт, якщо є зв'язані з ним об'єкти.

3. models.SET_NULL -- встановлює NULL в пов'язаних полях.

4. models.SET_DEFAULT -- встановлює значення за замовчуванням у зв'язаних полях.

5. models.SET() -- дозволяє встановити значення через функцію.

6. models.DO_NOTHING -- не вживає жодних дій при видаленні об'єкта.

Ці параметри дають гнучкість у визначенні поведінки ваших зв'язків і допомагають контролювати цілісність даних при видаленні об'єктів.

## **Що таке зворотні відносини**? What are backward relations?**

У Django зворотні  відносини (backward relations) --- це  спосіб  доступу  до  об'єктів, які  мають  зв'язок  із  поточним  об'єктом, через  зворотні  зв'язки. Тобто, якщо у вас є дві моделі з відносинами один до багатьох, багато до одного чи багато до багатьох, то ви можете використовувати зворотний зв'язок для того, щоб знайти всі пов'язані об'єкти з іншої моделі.

Як працюють зворотні відносини?

У кожному зв'язку між моделями, Django автоматично створює зворотний зв'язок, через який можна отримати доступ до об'єктів з іншої моделі.

Приклад 1: Зворотний зв'язок в One-to-Many (Один до багатьох)

Якщо у вас є відносини "один до багатьох" (наприклад, автор має багато книг), то зворотний зв'язок дозволяє отримати всі книги, пов'язані з певним автором.

Приклад:

from django.db import models

class Author(models.Model):

 name = models.CharField(max_length=100)

class Book(models.Model):

 title = models.CharField(max_length=200)

 author = models.ForeignKey(Author, on_delete=models.CASCADE)

У  цьому  випадку, Django автоматично  створює  зворотний  зв'язок  для  поля author в  моделі Book, і  це  ім'я  за  замовчуванням  буде book_set.

Як використовувати зворотний зв'язок:

# Припустимо, що у нас є автор

author = Author.objects.get(id=1)

# Отримуємо всі книги цього автора через зворотний зв'язок

books = author.book_set.all()

for book in books:

 print(book.title)

Тут book_set --- це зворотний зв'язок, за допомогою якого ви можете отримати всі книги, що належать даному автору.

Перевизначення зворотного зв'язку:

Якщо ви хочете дати зворотному зв'язку більш зрозуміле ім'я, можна використати параметр related_name в ForeignKey.

Приклад:

class Author(models.Model):

 name = models.CharField(max_length=100)

class Book(models.Model):

 title = models.CharField(max_length=200)

 author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name='books')

Тепер замість book_set ви можете використовувати ім'я books:

# Отримуємо всі книги цього автора через зворотний зв'язок

books = author.books.all()

for book in books:

 print(book.title)

Приклад 2: Зворотний  зв'язок  в Many-to-Many (Багато  до  багатьох)

Якщо  ви  маєте  відносини  багато  до  багатьох, зворотний  зв'язок  дозволяє  отримати  всі  об'єкти  з  іншої  моделі, які  зв'язані  з  поточним  об'єктом.

Приклад:

class Student(models.Model):

 name = models.CharField(max_length=100)

class Course(models.Model):

 title = models.CharField(max_length=200)

 students = models.ManyToManyField(Student)

У  цьому  випадку, Django автоматично  створює  зворотний  зв'язок  для  поля students в  моделі Course, і  це  ім'я  за  замовчуванням  буде student_set.

Як використовувати зворотний зв'язок:

# Отримуємо всі курси для певного студента через зворотний зв'язок

student = Student.objects.get(id=1)

courses = student.course_set.all()

for course in courses:

 print(course.title)

Перевизначення зворотного зв'язку в Many-to-Many

Подібно до ForeignKey, ви можете використовувати параметр related_name для більш зручного зворотного зв'язку в ManyToManyField.

Приклад:

class Student(models.Model):

 name = models.CharField(max_length=100)

class Course(models.Model):

 title = models.CharField(max_length=200)

 students = models.ManyToManyField(Student, related_name='courses')

Тепер  замість course_set ви  можете  використовувати  ім'я courses:

# Отримуємо всі курси для певного студента

student = Student.objects.get(id=1)

courses = student.courses.all()

for course in courses:

 print(course.title)

Зворотний  зв'язок  у One-to-One відносинах

У відносинах One-to-One зворотний зв'язок також можна отримати, але він буде створений через ім'я моделі. Ви можете визначити зворотний зв'язок, використовуючи параметр related_name.

Приклад:

class User(models.Model):

 username = models.CharField(max_length=100)

class Profile(models.Model):

 user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='profile')

 bio = models.TextField()

Тепер ви можете доступатися до профілю користувача через profile:

# Отримуємо профіль користувача

user = User.objects.get(id=1)

profile = user.profile

print(profile.bio)

Підсумок:

-   Зворотні відносини дозволяють отримати доступ до об'єктів, які зв'язані з поточним об'єктом.
-   Django автоматично створює зворотний зв'язок для полів ForeignKey, ManyToManyField і OneToOneField.
-   За замовчуванням зворотний зв'язок має ім'я, що включає назву моделі з _set (наприклад, book_set або course_set).
-   Ви можете змінити ім'я зворотного зв'язку, використовуючи параметр related_name.

## **Яке призначення проміжної таблиці (багато-до-багатьох)?** (many-to-many)

Проміжна  таблиця  в  багато  до  багатьох (many-to-many)відносинах  в Django виконує  важливу  роль  у  зберіганні  зв'язків  між  двома  моделями, коли  кожен  об'єкт  з  однієї  моделі  може  бути  пов'язаний  з  багатьма  об'єктами  з  іншої  моделі, і  навпаки.

Призначення  проміжної  таблиці:

У  відносинах "багато  до  багатьох" Django створює  проміжну  таблицю, щоб  зберігати  ці  зв'язки. Проміжна таблиця не має прямого представлення в коді моделей, якщо ви не визначаєте її вручну, але Django автоматично створює її за допомогою ManyToManyField.

Ця таблиця:

1. Зберігає зв'язки між об'єктами двох моделей.

2. Не зберігає додаткових даних (якщо тільки ви не вказали інше), але це може бути корисним у певних випадках, коли потрібно зберігати додаткові атрибути або метадані для кожного зв'язку.

Як працює проміжна таблиця?

Наприклад, у вас є моделі Student і Course, і кожен студент може бути записаний на кілька курсів, а кожен курс може мати кілька студентів. Для цього Django створює проміжну таблицю для зберігання цих зв'язків.

Приклад  моделей:

class Student(models.Model):

 name = models.CharField(max_length=100)

class Course(models.Model):

 title = models.CharField(max_length=200)

 students = models.ManyToManyField(Student)

У  цьому  випадку Django автоматично  створює  таблицю, яку  ми  можемо  назвати course_students (назва  таблиці  зазвичай  є  комбінацією  назв  двох  моделей, відсортованих  за  алфавітом). Ця таблиця міститиме два стовпці:

-   student_id --- посилання на студента.
-   course_id --- посилання на курс.

Проміжна таблиця в дії:

-   Для кожного запису в таблиці course_students буде зберігатися зв'язок між конкретним студентом та курсом, на якому цей студент навчається.
-   Наприклад, якщо студент на ім'я "Олександр" записаний на курс "Математика", то в проміжній таблиці буде запис з student_id для Олександра та course_id для курсу "Математика".

Коли потрібно вручну створювати проміжну таблицю?

Іноді вам потрібно не лише зберігати зв'язки між моделями, але й зберігати додаткові дані, які відносяться до кожного конкретного зв'язку. Наприклад, ви хочете зберігати дату реєстрації студента на курс або оцінку студента за курс.

В такому випадку ви можете створити власну проміжну таблицю через through параметр у ManyToManyField.

Приклад: Використання власної проміжної таблиці

class Enrollment(models.Model):

 student = models.ForeignKey(Student, on_delete=models.CASCADE)

 course = models.ForeignKey(Course, on_delete=models.CASCADE)

 registration_date = models.DateTimeField(auto_now_add=True)

 grade = models.CharField(max_length=2)

class Course(models.Model):

 title = models.CharField(max_length=200)

 students = models.ManyToManyField(Student, through='Enrollment')

У цьому прикладі ми створили власну таблицю Enrollment, яка є проміжною таблицею між студентами та курсами. Ця таблиця зберігає додаткову інформацію про дату реєстрації студента та його оцінку за курс.

-   through='Enrollment' --- вказує Django використовувати модель Enrollment як проміжну таблицю для зв'язку між студентами та курсами.
-   В такому випадку Django не створює автоматично проміжну таблицю, а використовує визначену вами модель для зберігання зв'язків і додаткових атрибутів.

Підсумок:

-   Проміжна таблиця в many-to-many відносинах використовується для зберігання зв'язків між об'єктами двох моделей.
-   Вона автоматично створюється Django, коли ви використовуєте ManyToManyField без параметра through.
-   Якщо вам потрібно зберігати додаткові дані для кожного зв'язку, ви можете створити власну проміжну таблицю (модель) за допомогою параметра through.

## **Що таке менеджери**? What are managers?**

У Django **менеджери** (managers) --- це  спеціальні  об'єкти, які  використовуються  для  взаємодії  з  базою  даних  та  виконання  запитів  до  моделей. Вони надають методи для створення, отримання, оновлення, видалення та фільтрації записів у таблиці, яка відповідає певній моделі.

Менеджери є частиною моделі в Django і за замовчуванням додаються до кожної моделі. Менеджери дозволяють виконувати операції з базою даних на рівні моделі, що забезпечує зручний і ефективний спосіб роботи з даними.

**Призначення менеджерів:**

-   **Запити до бази даних**: Через менеджери ви отримуєте доступ до таблиці в базі даних, яка відповідає моделі, і виконуєте запити, такі як фільтрація, сортування, отримання першого запису тощо.
-   **Створення і виконання складних запитів**: Менеджери дозволяють створювати кастомні методи для більш складних або часто використовуваних запитів.
-   **Створення абстракцій над стандартними методами Django ORM**: Ви можете визначити методи для часто використовуваних операцій, що спрощує код і підвищує його повторне використання.

**За замовчуванням:**

У кожній моделі Django є менеджер за замовчуванням, який називається **objects**. Це стандартний менеджер, який надає основні методи для роботи з базою даних.

**Приклад**:

class Book(models.Model):

 title = models.CharField(max_length=100)

 author = models.CharField(max_length=100)

# Використання  стандартного  менеджера objects

books = Book.objects.all() # отримує  всі  книги  з  бази  даних

first_book = Book.objects.first() # отримує  першу  книгу

books_by_author = Book.objects.filter(author='J.K. Rowling') # фільтрація  за  автором

**Кастомні менеджери:**

Іноді вам може знадобитися додати спеціальні методи до менеджера для виконання специфічних запитів, яких немає в стандартному менеджері. Ви можете створити власний менеджер, визначивши клас, який успадковує від models.Manager.

**Приклад****кастомного****менеджера****:**

class BookManager(models.Manager):

 def get_books_by_author(self, author_name):

 return self.filter(author=author_name)

 def get_books_with_long_titles(self):

 return self.filter(title__length__gt=50)

class Book(models.Model):

 title = models.CharField(max_length=100)

 author = models.CharField(max_length=100)

# Вказуємо  кастомний  менеджер

 objects = BookManager()

У цьому прикладі:

-   **get_books_by_author**: повертає всі книги певного автора.
-   **get_books_with_long_titles**: повертає всі книги, у яких назва складається з більше ніж 50 символів.

Тепер ви можете використовувати ці методи через менеджер:

books_by_author = Book.objects.get_books_by_author('J.K. Rowling')

books_with_long_titles = Book.objects.get_books_with_long_titles()

**Як працюють менеджери?**

-   Менеджери є доступними через атрибут **objects** (за замовчуванням) в моделі.
-   Ви можете створити власний менеджер, додавши його до моделі через клас Manager.
-   Менеджери можуть включати спеціальні методи, які інкапсулюють складні запити та логіку взаємодії з базою даних.

**Переваги використання менеджерів:**

1. **Реусабельність (повторне використання)**: Кастомні методи можуть бути використані в будь-якому місці вашого проекту, що дозволяє зменшити дублювання коду.

2. **Інкапсуляція логіки**: Ви можете ізолювати складну логіку запитів від основного коду, що спрощує його тестування і читабельність.

3. **Полегшення тестування**: Логіка запитів може бути поміщена в менеджери, що полегшує її тестування.

**Методи стандартного менеджера objects:**

-   **all()** --- отримує всі записи в таблиці.
-   **filter()** --- фільтрує записи за умовами.
-   **exclude()** --- виключає записи, які відповідають умовам.
-   **get()** --- отримує єдиний запис, що відповідає умовам (якщо їх більше або менше, то викликається виключення).
-   **first()** --- отримує перший запис.
-   **last()** --- отримує останній запис.
-   **count()** --- отримує кількість записів.
-   **aggregate()** --- виконує агрегатні операції (наприклад, сума, середнє).
-   **order_by()** --- сортує записи за вказаними полями.

**Приклад застосування кількох менеджерів:**

Іноді у вас може бути кілька кастомних менеджерів, і ви можете використовувати їх разом.

class PublishedBookManager(models.Manager):

 def published(self):

 return self.filter(is_published=True)

class DraftBookManager(models.Manager):

 def drafts(self):

 return self.filter(is_published=False)

class Book(models.Model):

 title = models.CharField(max_length=100)

 author = models.CharField(max_length=100)

 is_published = models.BooleanField()

 published_books = PublishedBookManager()

 draft_books = DraftBookManager()

У  цьому  випадку  ми  маємо  два  кастомних  менеджери:

-   **published_books**: для  отримання  всіх  опублікованих  книг.
-   **draft_books**: для отримання всіх чернеток.

**Висновок****:**

Менеджери в Django --- це інструмент для абстрагування взаємодії з базою даних. Вони дозволяють виконувати запити, використовувати методи для складних запитів і зберігати бізнес-логіку в одному місці, що робить код чистішим, зрозумілішим і зручнішим для тестування.

## **Що означає фраза Querysets are lazy?**

Фраза "Querysets are lazy" у контексті Django означає, що запити до бази даних, що створюються за допомогою QuerySet, не виконуються одразу, а лише коли вони фактично необхідні. Іншими словами, Django не виконує запит до бази даних на момент створення QuerySet, а лише коли ви намагаєтесь отримати або обробити дані.

Як це працює?

Lazy (відкладене виконання) означає, що запит до бази даних не буде виконаний, поки ви не намагатиметесь працювати з даними. Тільки коли ви виконуєте операцію, яка потребує даних (наприклад, проходите по результатах, перетворюєте їх на список, або ітеруєте через них), запит буде насправді відправлений до бази даних.

Приклад:

# Створення QuerySet

queryset = Book.objects.filter(author='J.K. Rowling')

# До цього моменту запит до бази даних ще не був виконаний!

# Тепер ми звертаємось до результату, і запит буде виконано:

books = list(queryset) # Запит до бази даних виконується тут

В цьому прикладі запит до бази даних не виконується, коли ми створюємо QuerySet queryset, а лише після того, як ми намагаємось перетворити його на список через list(queryset) або іншим способом отримати результат.

Як це допомагає?

1. Ефективність: Оскільки запит виконується тільки тоді, коли це необхідно, це дає Django можливість оптимізувати кількість запитів до бази даних.

2. Можливість ланцюжкових операцій: Ви можете додавати фільтрацію, сортування або інші операції до QuerySet без виконання запитів на кожному кроці. Базовий запит до бази даних буде виконано лише один раз після того, як ви візьмете результат.

Наприклад:

queryset = Book.objects.filter(author='J.K. Rowling') # Поки ще не виконується запит

queryset = queryset.filter(title__contains='Harry Potter') # Додається  ще  одна  фільтрація

queryset = queryset.order_by('title') # Додається  сортування

books = list(queryset) # Запит  виконано  тільки  тут

3. Можливість  лінійної  обробки: Ви  можете  працювати  з QuerySet як  з  об'єктом, який  виконується  лише  коли  це  потрібно, зберігаючи  при  цьому  ефективність  пам'яті  та  швидкість.

Коли запит виконується?

Запит до бази даних буде фактично виконаний тільки в таких випадках:

-   Коли ви викликаєте методи, які вимагають результату, наприклад:

-   list(queryset)
-   for obj in queryset:
-   queryset.first(), queryset.last(), queryset.count(), queryset.exists(), тощо.

-   Коли ви намагаєтеся звернутися до результату безпосередньо, наприклад:

-   queryset[0] (перший елемент).

Якщо ж ви просто створюєте QuerySet і не викликаєте методи, які вимагають результату, Django не виконує запит до бази даних.

Переваги лінійного виконання:

1. Оптимізація запитів: Якщо ви послідовно додаєте фільтри чи інші операції до QuerySet, Django буде оптимізувати запит, щоб виконати його лише один раз. Це допомагає уникнути надлишкових запитів до бази даних.

2. Економія пам'яті: Лінійне виконання означає, що обробка великих об'ємів даних відбувається лише коли це необхідно, що дозволяє працювати з меншими обсягами пам'яті при відкладеному виконанні.

Висновок:

Lazy QuerySets --- це механізм в Django, який дозволяє вам створювати складні запити без виконання їх до того моменту, поки ви реально не звернетеся до результатів. Це дозволяє зберігати ресурси та оптимізувати роботу з базою даних.

## **Що таке пошуки?lookups?**

Lookups в Django ORM --- це спеціальні механізми для виконання фільтрації і пошуку по даним у базі даних, де ви використовуєте операції, щоб знаходити записи, що задовольняють певним умовам.

Загалом, lookups визначають, як можна порівнювати значення в базі даних з певними значеннями або умовами. Django дозволяє використовувати різноманітні lookups для фільтрації об'єктів і порівняння значень.

Приклади використання lookups

1. Основні оператори фільтрації:

o exact --- точне співпадіння.

o iexact --- точне співпадіння без врахування регістру.

o contains --- перевіряє, чи містить поле певний текст.

o icontains --- перевіряє, чи містить поле певний текст без врахування регістру.

o gt --- більше  ніж (greater than).

o gte --- більше  або  дорівнює (greater than or equal to).

o lt --- менше  ніж (less than).

o lte --- менше  або  дорівнює (less than or equal to).

o in --- значення поля повинно бути в певному списку.

o isnull --- перевіряє, чи є поле NULL.

2. Приклад використання lookups:

from myapp.models import Book

# Пошук книги за точним назвою (exact match)

books_exact = Book.objects.filter(title__exact='Django for Beginners')

# Пошук книги, де назва містить певне слово

books_contains = Book.objects.filter(title__contains='Django')

# Пошук книг, де автор починається з "John"

books_startswith = Book.objects.filter(author__startswith='John')

# Пошук  книг, де  рік  публікації  більше 2000

books_after_2000 = Book.objects.filter(pub_year__gt=2000)

# Пошук книг за автором з урахуванням регістру

books_author_exact = Book.objects.filter(author__iexact='j.k. rowling')

# Пошук книг, де рік публікації в межах певного діапазону

books_in_range = Book.objects.filter(pub_year__in=[1999, 2000, 2001])

# Пошук  книг, де  рік  публікації  відсутній (NULL)

books_no_pub_year = Book.objects.filter(pub_year__isnull=True)

Опис основних типів lookups:

1. Точні порівняння:

o exact і iexact порівнюють значення точно, враховуючи або не враховуючи регістр.

o exact --- це по суті перевірка на точне співпадіння.

o iexact --- це те ж саме, але без урахування регістру (наприклад, "Django" і "django" вважатимуться однаковими).

2. Часткові співпадіння:

o contains і icontains перевіряють, чи містить поле певний текст.

o contains чутливий до регістру, а icontains --- ні.

3. Порівняння з числами:

o gt (greater than) --- перевіряє, чи значення більше за вказане.

o gte (greater than or equal to) --- перевіряє, чи значення більше або дорівнює вказаному.

o lt (less than) --- перевіряє, чи значення менше за вказане.

o lte (less than or equal to) --- перевіряє, чи значення менше або дорівнює вказаному.

4. Перевірка на наявність в списку:

o in дозволяє перевірити, чи входить значення в певний список або множину.

5. Перевірка на наявність значення (NULL):

o isnull перевіряє, чи є значення в полі відсутнім (NULL).

6. Пошук за частиною рядка (порівняння початку, кінця):

o startswith і endswith використовуються для перевірки того, чи починається чи закінчується рядок на певний текст.

7. Числові та датовані значення:

o Django також підтримує порівняння з датами та числовими значеннями, що робить ці lookups корисними для фільтрації по датах або числових діапазонах.

Приклад пошуку за допомогою різних lookups:

# Пошук книги, де назва починається з "Django"

books_starts_with_django = Book.objects.filter(title__startswith="Django")

# Пошук книги, де назва не є точною "Python" (тобто, не має такої назви)

books_not_python = Book.objects.exclude(title__exact="Python")

# Пошук  книги, рік  публікації  якої  більше 2010

books_after_2010 = Book.objects.filter(pub_year__gt=2010)

# Пошук книги за авторами, де ім'я містить "Rowling"

books_by_rowling = Book.objects.filter(author__contains="Rowling")

# Пошук  за  набором  років  публікації

books_in_years = Book.objects.filter(pub_year__in=[2000, 2005, 2010])

# Пошук за полем, що є NULL

books_without_pub_year = Book.objects.filter(pub_year__isnull=True)

Логіка роботи з lookups

-   Подвійне підкреслення (__) --- це спосіб вказати lookup, який ви хочете використовувати для поля. Наприклад:

-   title__contains='Django' --- перевіряє, чи містить поле title слово "Django".
-   pub_year__gt=2000 --- перевіряє, чи більше значення в полі pub_year, ніж 2000.

Висновок:

Lookups у Django дозволяють створювати потужні фільтри для пошуку даних в базі даних, застосовуючи різноманітні порівняння. Використовуючи lookups, ви можете фільтрувати записи за точним, частковим співпадінням, за числовими або датованими значеннями, а також перевіряти значення на NULL чи наявність в списку.

## **Як об'єднання реалізовано в Django ORM? How joins are implemented in Django ORM?**

В Django ORM об'єднання (від  англ. Union) реалізовано  через  використання  методу union(),  який  дозволяє  об'єднувати  два  або  більше QuerySets. За допомогою цього методу ви можете створити комбінований запит, який повертає результати з кількох запитів одночасно.

Основи використання union()

Метод union() дозволяє об'єднувати два або більше QuerySets, повертаючи їхні результати в єдиному наборі даних. Кожен QuerySet, що використовується в union(), повинен мати однакову кількість і типи полів. Також важливо, що Django не дозволяє дублювання записів у результаті об'єднання (як SQL-операція UNION).

Синтаксис:

queryset1 = Model.objects.filter(условие1)

queryset2 = Model.objects.filter(условие2)

combined_queryset = queryset1.union(queryset2)

Особливості:

-   Результат об'єднання міститиме тільки унікальні записи (як при використанні SQL UNION).
-   Усі QuerySets повинні бути на одній моделі або принаймні на моделях з однаковими полями.
-   Якщо ви хочете включити дублікати, вам слід використовувати метод union() з параметром all=True.

Приклад використання union():

Уявімо, що у вас є модель Book з полем author і ви хочете об'єднати книги певних авторів:

from myapp.models import Book

# Запит для книг певного автора

books_by_author_1 = Book.objects.filter(author='J.K. Rowling')

# Запит  для  книг  іншого  автора

books_by_author_2 = Book.objects.filter(author='George R.R. Martin')

# Об'єднання  результатів  двох  запитів

combined_books = books_by_author_1.union(books_by_author_2)

# Тепер combined_books містить  книги  як  від J.K. Rowling, так  і  від George R.R. Martin

Використання з іншими моделями:

Якщо ви хочете об'єднати запити до різних моделей, ви можете це зробити, але лише якщо обидві моделі мають однакову кількість і типи полів. Наприклад:

from myapp.models import Book, Author

# Запит  до  моделі Book

books = Book.objects.filter(pub_year__gt=2000)

# Запит до моделі Author (наприклад, фільтруємо за іменем автора)

authors = Author.objects.filter(name__startswith='J')

# Об'єднуємо  результати

combined = books.union(authors)

Важливо пам'ятати, що це можливо лише в тому випадку, якщо поля в обох моделях сумісні. Якщо поля відрізняються за типом або кількістю, ви отримаєте помилку.

Параметр all=True:

Якщо ви хочете включити дублікати в результат (як це відбувається в SQL-операції UNION ALL), можна передати параметр all=True.

combined_with_duplicates = books_by_author_1.union(books_by_author_2, all=True)

Приклад з полями різного типу:

Якщо вам потрібно об'єднати QuerySets з різними полями або на різних моделях, ви можете використовувати методи, щоб привести поля до спільного формату. Наприклад, ви можете вибрати тільки певні поля:

# Обираємо тільки потрібні поля в обох запитах

books = Book.objects.filter(pub_year__gt=2000).values('title', 'author')

authors = Author.objects.filter(name__startswith='J').values('name', 'birthdate')

combined = books.union(authors)

Висновок:

Метод union() в Django ORM  дозволяє  об'єднувати  результати  кількох QuerySets в  єдину  колекцію. Це дуже корисно, коли ви хочете отримати всі результати за кількома умовами або з кількох джерел, зберігаючи при цьому унікальність записів. Важливо пам'ятати, що поля в об'єднуваних QuerySets повинні бути сумісними, тобто мати однакову кількість і типи полів.

## **Що таке кешування набору запитів?** queryset caching

**Кешування набору запитів (queryset caching)** в Django --- це механізм, що дозволяє зберігати результати виконання запиту до бази даних, щоб уникнути повторних запитів до бази даних при наступних зверненнях до того ж самого **QuerySet**. Це значно підвищує ефективність і знижує навантаження на базу даних.

У Django **QuerySet** є **lazy** (відкладеним), що означає, що запит до бази даних не виконується при створенні **QuerySet**, а лише тоді, коли ви починаєте працювати з результатами (наприклад, ітеруєте через них або використовуєте такі методи, як list(), first(), last()).

**Як працює кешування QuerySet?**

1. **Lazy Evaluation**: Коли ви створюєте **QuerySet**, Django не виконує запит до бази даних одразу. Запит буде виконано лише тоді, коли ви реально звертаєтесь до результатів.

2. **Кешування результатів**: Після того, як запит до бази даних був виконаний, результати кешуються в пам'яті. Якщо ви знову звернетеся до того ж **QuerySet**, Django не буде виконувати запит до бази даних, а просто використовуватиме кешовані результати.

Це дозволяє уникнути зайвих запитів до бази даних, покращуючи продуктивність додатка, особливо якщо результат запиту великий і багаторазово використовується.

**Кешування при ітераціях та доступі до результатів**

**1\. Ітерація по QuerySet**

Коли ви ітеруєте по **QuerySet**, Django виконує запит до бази даних тільки один раз. Потім результати кешуються в об'єкті **QuerySet**, і якщо ви знову ітеруєте через нього, запит до бази даних не буде повторно виконано.

# Створення QuerySet

queryset = Book.objects.filter(author="J.K. Rowling")

# Перший прохід - запит до бази даних виконується

for book in queryset:

 print(book.title)

# Другий прохід - запит до бази даних не виконується, використовуються кешовані результати

for book in queryset:

 print(book.title)

**2\. Використання методів, що повертають результати**

Якщо ви використовуєте методи, які отримують результат запиту (наприклад, first(), last(), count(), exists()), Django виконає запит до бази даних тільки один раз, а потім кешує результат.

# Перший виклик виконує запит до бази даних

book = queryset.first()

# Повторний виклик не буде виконувати запит до бази даних

book = queryset.first()

**Кешування в межах одного запиту**

**QuerySet** кешується в межах одного запиту до веб-додатку (request). Це означає, що поки ви не завершите обробку поточного запиту, Django буде використовувати кешовані результати для всіх звернень до того самого **QuerySet**.

**Очищення кешу QuerySet**

1. **Очистка кешу вручну**: Якщо ви хочете очистити кеш результатів, можна використовувати метод **queryset._clear_cache()**. Це може бути корисно, якщо ви хочете повторно виконати запит до бази даних після змін у даних.

queryset = Book.objects.filter(author='J.K. Rowling')

queryset._clear_cache()

2. **Новий запит**: Якщо ви створюєте новий **QuerySet**, кеш попереднього запиту буде очищено, і запит буде виконано знову.

**Важливі моменти:**

1. **Фільтрація після кешування**: Якщо ви виконали фільтрацію над **QuerySet**, після кешування, нові фільтри застосовувати не будуть. Тому, якщо ви змінюєте фільтрацію, необхідно створювати новий **QuerySet**.

queryset = Book.objects.filter(author="J.K. Rowling")

queryset = queryset.filter(pub_year__gt=2000)  # Новий запит, нові результати

2. **Кешування в кеші додатку (для великих даних)**: Для більш ефективного кешування в реальних проєктах можна використовувати додаткові механізми кешування, наприклад, кешування на рівні додатка через Redis, Memcached або інші кеш-системи, щоб зберігати результати запитів між запитами користувачів.

**Приклад кешування на рівні запиту:**

# Створення QuerySet

books = Book.objects.filter(author='J.K. Rowling')

# Виконання запиту до бази даних

books_list = list(books)

# Подальші запити не будуть виконуватися до бази даних

for book in books:

 print(book.title)

У цьому прикладі:

-   **QuerySet** books виконується один раз при використанні list(books), і всі подальші звернення до цього **QuerySet** не викликають новий запит до бази даних.
-   Ви отримуєте кешовані результати, поки не завершиться обробка поточного запиту.

**Переваги кешування QuerySet:**

-   **Зменшення кількості запитів**: Якщо ви виконуєте один і той же запит кілька разів, Django не буде виконувати його повторно.
-   **Підвищення продуктивності**: Зменшення навантаження на базу даних, оскільки не потрібно виконувати один і той самий запит кілька разів.
-   **Мінімізація часу обробки**: Повторне використання результатів запиту допомагає швидше обробляти дані.

**Висновок****:**

**Кешування QuerySet** в Django значно підвищує ефективність запитів до бази даних, дозволяючи повторно використовувати результати запиту протягом життя одного запиту до додатку. Це зменшує кількість запитів і підвищує продуктивність, дозволяючи уникнути зайвих звернень до бази даних.

## **Що таке анотації / агрегації**? **annotations/aggregations?**

Анотації (annotations) та  агрегації (aggregations) в Django ORM є  потужними  інструментами  для  обробки  та  трансформації  даних  без  необхідності  виконувати  складні SQL-запити  вручну. Вони дозволяють виконувати розрахунки над полями в базі даних і додавати результати до об'єктів QuerySet.

1\. Анотації (Annotations)

Анотації дозволяють додавати додаткові обчислювані поля до кожного елемента в QuerySet на основі існуючих полів таблиці. Це означає, що ви можете додавати до кожного об'єкта нові значення, які є результатом математичних або агрегуючих операцій.

Приклад використання анотацій

Уявімо, що у вас є модель Book, і ви хочете додати до кожної книги кількість сторінок у зв'язку з її chapter:

from django.db.models import Count

from myapp.models import Book

# Додаємо  анотацію, що  вказує  на  кількість  глав  у  книзі

books = Book.objects.annotate(chapters_count=Count('chapters'))

for book in books:

 print(book.title, book.chapters_count)

У цьому прикладі:

-   annotate() додає нове поле chapters_count, яке містить кількість пов'язаних записів з таблиці chapters для кожної книги.
-   Count --- це функція агрегації, яка рахує кількість пов'язаних записів.

2\. Агрегації (Aggregations)

Агрегація дозволяє виконувати операції на всьому наборі даних (для всього QuerySet) і отримувати єдині значення. Це використовується для обчислення сум, середніх значень, мінімумів, максимумів і т.д., замість того, щоб працювати з кожним окремим об'єктом.

Приклад використання агрегацій

Уявімо, що ви хочете обчислити середню кількість сторінок у книгах:

from django.db.models import Avg

from myapp.models import Book

# Обчислення  середньої  кількості  сторінок  у  всіх  книгах

average_pages = Book.objects.aggregate(Avg('pages'))

print(average_pages)

У  цьому  прикладі:

-   aggregate() застосовує  функцію  агрегації Avg до  всього QuerySet.
-   Результат міститиме середнє значення по полю pages для всіх книг у базі даних.

Інші типи агрегацій:

-   Sum: Sum('field') --- сума значень в полі.
-   Max: Max('field') --- максимальне значення в полі.
-   Min: Min('field') --- мінімальне значення в полі.
-   Count: Count('field') --- кількість непустих значень у полі.

Порівняння Анотацій та Агрегацій

-   Анотації: Додають нові значення до кожного запису в QuerySet. Зазвичай використовуються для виконання операцій над полями конкретних об'єктів.
-   Агрегації: Повертають єдине значення для всього QuerySet, наприклад, суму, середнє, мінімум або максимум.

3\. Приклад комбінації анотацій і агрегацій

Ви можете використовувати агрегацію та анотацію разом. Наприклад, ви хочете отримати середню кількість глав у книгах, а також кількість книг, що мають більше ніж 200 сторінок:

from django.db.models import Count, Avg, Q

from myapp.models import Book

# Обчислення  середньої  кількості  глав  у  книгах  та  кількості  книг  з  більше  ніж 200 сторінок

result = Book.objects.annotate(

 chapters_count=Count('chapters')

).aggregate(

 avg_chapters=Avg('chapters_count'),

 books_with_200_pages=Count('id', filter=Q(pages__gt=200))

)

print(result)

У  цьому  прикладі:

-   Ми використовуємо annotate() для обчислення кількості глав для кожної книги.
-   Потім за допомогою aggregate() обчислюємо середню кількість глав та кількість книг з більш ніж 200 сторінками.

4\. Функції для анотацій та агрегацій

Django надає різні функції для анотацій і агрегацій. Ось деякі з них:

-   Count: рахує кількість непустих значень або записів.
-   Sum: обчислює суму значень.
-   Avg: обчислює середнє значення.
-   Max: обчислює максимальне значення.
-   Min: обчислює мінімальне значення.
-   F: дозволяє використовувати значення з інших полів у запитах для анотацій.
-   Q: дозволяє будувати складні умови фільтрації для агрегацій.

Приклад використання F:

from django.db.models import F, Sum

from myapp.models import Book

# Додавання анотації для розрахунку різниці між сторінками і главами

books = Book.objects.annotate(

 pages_per_chapter=F('pages') / F('chapters_count')

)

# Тепер ви можете працювати з цим значенням

for book in books:

 print(book.title, book.pages_per_chapter)

5\. Приклад: Агрегація  з  фільтрацією

Іноді  потрібно  застосовувати  агрегацію  з  додатковими  умовами:

from django.db.models import Count, Q

from myapp.models import Book

# Підрахувати  кількість  книг, що  мають  більше  ніж 300 сторінок

books_with_large_pages = Book.objects.aggregate(

 count_large_books=Count('id', filter=Q(pages__gt=300))

)

print(books_with_large_pages)

Висновок

Анотації та агрегації в Django ORM --- це інструменти для виконання обчислень та аналізу даних у базі даних. Анотації дозволяють додавати обчислені поля до кожного запису в QuerySet, а агрегації дають змогу отримувати зведені дані для всього QuerySet, як-то середнє значення, сума або кількість.

Використання цих функцій дозволяє зменшити кількість запитів до бази даних, оскільки всі обчислення виконуються на рівні бази даних, а не в коді Python.

## **Для чого використовуються select_related/prefetch_related?** What are select_related/prefetch_related used for?**

select_related та prefetch_related --- це два  методи  в Django ORM, які  використовуються  для  оптимізації  запитів  і  зменшення  кількості  запитів  до  бази  даних  при  роботі  з  відносинами  між  моделями (наприклад, для ForeignKey, OneToOneта ManyToMany).

Вони дозволяють завантажувати зв'язані об'єкти з бази даних за допомогою оптимізованих запитів, що допомагає уникнути проблеми N+1 запитів.

1\. select_related

Метод select_related використовується для завантаження об'єктів у разі відносин типу ForeignKey або OneToOne в один запит, за допомогою SQL JOIN. Це означає, що пов'язані об'єкти будуть витягнуті разом з основними об'єктами, що дозволяє уникнути повторних запитів до бази даних для кожного пов'язаного об'єкта.

Як це працює:

-   select_related ефективний, коли вам потрібно завантажити пов'язані об'єкти в одну таблицю (через SQL JOIN).
-   Зазвичай його використовують для **відносин ForeignKey або OneToOne.

Приклад:

У вас є моделі Author та Book, де Book має зовнішній ключ на Author (тобто, кожна книга має автора):

class Author(models.Model):

 name = models.CharField(max_length=100)

class Book(models.Model):

 title = models.CharField(max_length=100)

 author = models.ForeignKey(Author, on_delete=models.CASCADE)

Тепер, якщо ви хочете отримати всі книги разом із відповідними авторами, використовуючи select_related:

# Без використання select_related

books = Book.objects.all()

for book in books:

print(book.title, book.author.name) # Для  кожної  книги  буде  виконано  окремий  запит  для  автора

# З  використанням select_related

books = Book.objects.select_related('author').all()

for book in books:

print(book.title, book.author.name) # Тепер  всі  дані  завантажуються  в  одному  запиті

У цьому прикладі:

-   select_related('author') виконує JOIN на таблиці Author, щоб витягти дані про автора одночасно з книгами, що зменшує кількість запитів до бази даних.

2\. prefetch_related

Метод prefetch_related використовується для **завантаження об'єктів у разі відносин типу ManyToMany або обернених відносин (тобто, коли одна модель має багато зв'язків з іншими моделями, і ви хочете отримати ці зв'язки).

prefetch_related працює через два запити: один для основної таблиці і другий для таблиці, що зберігає зв'язки (якщо йдеться про зв'язки типу ManyToMany чи ForeignKey зворотного напрямку). Потім Django об'єднує результати цих запитів у пам'яті.

Як це працює:

-   prefetch_related особливо корисний для відносин типу ManyToMany та обернених ForeignKey (тобто коли вам потрібно отримати всі зв'язані об'єкти у множині).
-   Він використовує два запити: один для основних об'єктів, а другий для запиту зв'язків.

Приклад:

У вас є моделі Author та Book, де Author має багато зв'язаних книг (відносини ManyToMany):

class Author(models.Model):

 name = models.CharField(max_length=100)

class Book(models.Model):

 title = models.CharField(max_length=100)

 authors = models.ManyToManyField(Author)

Тепер, щоб  отримати  всіх  авторів  разом  з  їхніми  книгами, ви  використовуєте prefetch_related:

# Без використання prefetch_related

authors = Author.objects.all()

for author in authors:

 print(author.name)

for book in author.book_set.all(): # Запит  для  кожного  автора

 print(book.title)

# З  використанням prefetch_related

authors = Author.objects.prefetch_related('book_set').all()

for author in authors:

 print(author.name)

for book in author.book_set.all(): # Тепер  всі  книги  завантажуються  в  одному  запиті

 print(book.title)

У  цьому  прикладі:

-   prefetch_related('book_set') виконує  два  запити:

-   Перший запит витягує всіх авторів.
-   Другий запит витягує всі книги, які пов'язані з авторами, і Django автоматично об'єднує їх в пам'яті, щоб не виконувати повторні запити для кожного автора.

3\. Коли  використовувати select_relatedі prefetch_related

-   select_related: Використовуйте  для ForeignKey та OneToOne відносин, коли  вам  потрібно  виконати JOIN на  таблиці  і  отримати  зв'язані  об'єкти  в  одному  запиті. Це ідеально підходить для однозв'язкових відносин.
-   prefetch_related: Використовуйте для ManyToMany та обернених ForeignKey відносин, коли вам потрібно зробити кілька запитів і об'єднати їх у пам'яті. Це ідеально підходить для багатозв'язкових відносин.

4\. Порівняння select_related і prefetch_related

|

Особливість

 |

select_related

 |

prefetch_related

 |
| --- | --- | --- |
|

Тип зв'язку

 |

ForeignKey або OneToOne

 |

ManyToMany або зворотний ForeignKey

 |
|

Кількість запитів

 |

Один запит з JOIN

 |

Два запити (один для основної моделі, інший для зв'язків)

 |
|

Продуктивність для простих зв'язків

 |

Висока (один запит)

 |

Нижча для простих зв'язків (два запити)

 |
|

Продуктивність для складних зв'язків

 |

Може бути менш ефективним для багатозв'язкових відносин

 |

Більш ефективне для ManyToMany і складних зв'язків

 |

Висновок

-   select_related є оптимальним для однозв'язкових відносин типу ForeignKey або OneToOne, коли вам потрібно зменшити кількість запитів через SQL JOIN.
-   prefetch_related є ідеальним для багатозв'язкових відносин типу ManyToMany або коли потрібно працювати з зворотними відносинами ForeignKey, де ви хочете уникнути N+1 запитів, але використовуєте два окремі запити для завантаження даних.

Використання обох методів допомагає значно покращити продуктивність і знизити кількість запитів до бази даних у Django, що є важливим для ефективного масштабування вашого застосунку.

## **Що таке клас Meta?**

У Django, клас Meta є внутрішнім класом, який використовується для налаштування різних аспектів моделі. Він дозволяє визначити мета-дані, які не є полями моделі, але керують її поведінкою та властивостями, такими як назва таблиці в базі даних, порядок сортування, обмеження, індекси та інші параметри.

Основні функції класу Meta

1. db_table: визначає ім'я таблиці в базі даних для цієї моделі. За замовчуванням Django автоматично генерує ім'я таблиці, яке базується на імені моделі в нижньому регістрі, але ви можете змінити це через db_table.

class Book(models.Model):

 title = models.CharField(max_length=100)

 class Meta:

 db_table = 'custom_table_name'

У цьому прикладі таблиця в базі даних буде називатися custom_table_name, а не автоматично згенероване ім'я.

2. ordering: задає порядок сортування об'єктів за замовчуванням, коли ви отримуєте їх з бази даних.

class Book(models.Model):

 title = models.CharField(max_length=100)

 publication_date = models.DateField()

 class Meta:

ordering = ['publication_date'] # Сортувати  за  датою  публікації

У цьому випадку всі книги будуть сортуватися за датою публікації у порядку зростання за замовчуванням.

3. verbose_name та verbose_name_plural: використовуються для визначення зрозумілих імен моделі в однині та множині, які будуть використовуватися в адміністративному інтерфейсі Django.

class Book(models.Model):

 title = models.CharField(max_length=100)

 class Meta:

 verbose_name = 'book'

 verbose_name_plural = 'books'

В адміністративному інтерфейсі Django ці значення будуть використовуватися для правильного відображення імен.

4. unique_together та unique: задають обмеження унікальності для одного або кількох полів.

o unique_together --- дозволяє вказати унікальне поєднання полів.

o unique --- робить поле унікальним.

class Book(models.Model):

 title = models.CharField(max_length=100)

 author = models.CharField(max_length=100)

 class Meta:

unique_together = ['title', 'author'] # Комбінація  цих  полів  повинна  бути  унікальною

У цьому прикладі, якщо спробувати додати дві книги з однаковими назвами та авторами, виникне помилка.

5. index_together та indexes: ці параметри визначають індекси, які будуть створюватися для певних полів у базі даних.

o index_together дозволяє створити комбіновані індекси для кількох полів.

o indexes дозволяє створювати індекси для конкретних полів або створювати індекси з більш складними виразами (наприклад, функціональні індекси).

from django.db import models

class Book(models.Model):

 title = models.CharField(max_length=100)

 author = models.CharField(max_length=100)

 class Meta:

 index_together = ['title', 'author']

 indexes = [

 models.Index(fields=['author']),

 ]

У цьому прикладі:

o Створюється комбінований індекс для полів title та author.

o Окремий індекс створюється для поля author.

6. default_related_name та related_name: ці параметри використовуються для налаштування зворотних відносин між моделями в разі використання зв'язків ForeignKey, OneToOne, або ManyToMany.

class Author(models.Model):

 name = models.CharField(max_length=100)

class Book(models.Model):

 title = models.CharField(max_length=100)

 author = models.ForeignKey(Author, on_delete=models.CASCADE)

 class Meta:

related_name = 'books' # Це  визначає  ім'я  зворотного  зв'язку

Тепер ви можете звертатися до всіх книг автора через атрибут books на об'єкті Author:

author = Author.objects.get(id=1)

books_by_author = author.books.all()

7. permissions: дозволяє задати власні набори прав доступу для моделі, які використовуватимуться в системі управління доступом Django.

class Book(models.Model):

 title = models.CharField(max_length=100)

 class Meta:

 permissions = [

 ("can_view_books", "Can view books"),

 ("can_edit_books", "Can edit books"),

 ]

Це дозволяє створити кастомні права доступу для моделі Book, які потім можна використовувати для контролю доступу до об'єктів цієї моделі.

8. app_label: використовується для вказівки на те, до якого додатку належить модель, якщо вона знаходиться в іншому каталозі або в іншому додатку.

class Book(models.Model):

 title = models.CharField(max_length=100)

 class Meta:

app_label = 'library' # Вказує  на  додаток 'library'

Приклад  використання  класу Meta:

class Book(models.Model):

 title = models.CharField(max_length=100)

 author = models.CharField(max_length=100)

 publication_date = models.DateField()

 class Meta:

 db_table = 'custom_books_table'

 ordering = ['publication_date']

 verbose_name = 'Book'

 verbose_name_plural = 'Books'

 unique_together = ['title', 'author']

 indexes = [

 models.Index(fields=['author']),

 ]

-   db_table --- вказує, що таблиця в базі даних буде мати ім'я custom_books_table.
-   ordering --- задає порядок сортування книг за датою публікації.
-   verbose_name і verbose_name_plural --- надають зрозумілі імена для цієї моделі в адміністраторському інтерфейсі.
-   unique_together --- забезпечує, що комбінація назви і автора буде унікальною.
-   indexes --- створює індекс на поле author.

Висновок

Клас Meta у Django є інструментом для налаштування поведінки моделей. Він дозволяє змінювати різні аспекти моделі без необхідності писати складний SQL-код, що допомагає значно спростити і зручніше працювати з моделями в Django.

## **Що таке індекси бази даних ?** What are database indexes?**

**Індекси бази даних** --- це спеціальні структури даних, які використовуються для прискорення пошуку та доступу до даних у таблицях бази даних. Індекси дозволяють значно зменшити час, який потрібен для виконання запитів, особливо коли таблиця містить багато записів.

**Основи індексів**

Індекс у базі даних схожий на пошуковий індекс в книзі: він дозволяє швидко знайти потрібну інформацію без необхідності переглядати всю таблицю. Замість того щоб шукати через кожен запис, база даних може звертатися до індексу, який зберігає місцезнаходження необхідних даних.

**Як працюють індекси?**

**Індекс** створюється на певних стовпцях таблиці і організовує ці значення у вигляді дерева (зазвичай B-дерево або хеш-таблиця), що дозволяє швидко виконувати операції пошуку. Кожен індекс зберігає значення стовпця та вказує на розташування відповідного запису в таблиці.

**Як працює індекс в запитах?**

Коли виконується запит, база даних може використовувати індекс, щоб швидко знайти необхідні рядки, не переглядаючи всю таблицю. Наприклад, запит на пошук запису по певному стовпцю:

SELECT * FROM books WHERE title = 'Django for Beginners';

Якщо на стовпець title створений індекс, база даних може швидко знайти потрібні записи через індекс замість того, щоб виконувати повний перегляд таблиці (повне сканування таблиці).

Типи індексів

1. Простий індекс (Single Column Index): Індекс, створений на одному стовпці таблиці. Це найпоширеніший тип індексу.

class Book(models.Model):

 title = models.CharField(max_length=100)

 class Meta:

 indexes = [

 models.Index(fields=['title'])

 ]

2. Комбінований індекс (Composite Index): Індекс, створений на кількох стовпцях. Такий індекс корисний, коли запити часто фільтруються або сортуються за кількома полями одночасно.

class Book(models.Model):

 title = models.CharField(max_length=100)

 author = models.CharField(max_length=100)

 class Meta:

 indexes = [

models.Index(fields=['title', 'author']) # Комбінований  індекс

 ]

3. Унікальний індекс (Unique Index): Індекс, який також накладає обмеження унікальності на стовпець або комбінацію стовпців. Це означає, що значення в цих стовпцях повинні бути унікальними.

class Book(models.Model):

 title = models.CharField(max_length=100, unique=True)

У цьому випадку для стовпця title автоматично створюється унікальний індекс, що гарантує відсутність дублюючих назв книг.

4. Індекс по виразу (Functional Index): Індекси, створені не просто на стовпцях, а на виразах або функціях. Наприклад, індекс на перші 3 літери назви книги.

from django.db import models

class Book(models.Model):

 title = models.CharField(max_length=100)

 class Meta:

 indexes = [

 models.Index(fields=['title'], name='title_prefix_index', using='btree')

 ]

5. Повнотекстовий індекс (Full-Text Index): Індекс, що використовується для оптимізації пошуку текстових даних, особливо у великих текстових полях.

У Django для таких індексів часто використовуються спеціалізовані рішення бази даних (наприклад, PostgreSQL Full-Text Search).

6. Індекси за замовчуванням (Default Indexes): Багато реляційних СУБД, як PostgreSQL або MySQL, автоматично створюють індекси для первинних ключів (Primary Key) та унікальних ключів (Unique Key).

Переваги використання індексів

1. Швидкий пошук: Індекси значно прискорюють виконання запитів SELECT, особливо якщо таблиця велика.

2. Швидке сортування: Запити, що включають сортування за індексованим полем, також будуть виконуватися швидше.

3. Швидка перевірка унікальності: Індекси допомагають швидко перевіряти, чи існують дублікати, якщо використовується обмеження унікальності.

Недоліки індексів

1. Додаткові ресурси: Індекси займають додатковий простір в базі даних.

2. Повільніші операції запису (INSERT, UPDATE, DELETE): При додаванні, оновленні або видаленні даних індекси потрібно оновлювати, що може знижувати продуктивність цих операцій.

3. Не завжди необхідно: Якщо індекс створений на полях, які не використовуються в запитах, він лише споживатиме ресурси без реальної користі.

Коли створювати індекси?

-   Створюйте індекси на стовпцях, які часто використовуються в умовах WHERE, ORDER BY, або в з'єднаннях JOIN.
-   Для полів, які часто використовуються для фільтрації або сортування, індекси будуть корисними.
-   Не створюйте індекси на полях, які змінюються дуже часто або рідко використовуються в запитах.

Приклад індексів у Django

У Django можна додавати індекси через мета-клас Meta моделі. Це робиться за допомогою параметра indexes або за допомогою поля з параметром unique.

from django.db import models

class Product(models.Model):

 name = models.CharField(max_length=100)

 price = models.DecimalField(max_digits=10, decimal_places=2)

 class Meta:

 indexes = [

models.Index(fields=['name']) # Індекс  на  поле name

models.Index(fields=['price']) # Індекс  на  поле price

 ]

У цьому прикладі для полів name і price створюються індекси, щоб пришвидшити пошук за цими полями.

**Висновок**

Індекси в базах даних є інструментом для підвищення продуктивності запитів. Вони дозволяють швидше знаходити дані, сортувати їх та виконувати операції з унікальності. Однак важливо використовувати їх з обережністю, оскільки вони можуть призвести до додаткових витрат на ресурси та сповільнення операцій запису.

## **Що таке обмеження (****унікальні****)?** What are constraints (unique)?**

**Обмеження**** (constraints) ****в****базах****даних**** --- **це  правила  або  умови, які  накладаються  на  стовпці  таблиці, щоб  забезпечити  цілісність  даних  та  дотримання  бізнес-логіки. Вони використовуються для контролю правильності введених даних та для забезпечення певних обмежень на дані в таблицях. Одним з найбільш поширених типів обмежень є унікальні обмеження (unique constraints).

Унікальне обмеження (Unique Constraint)

Унікальне обмеження гарантує, що всі значення в певному стовпці або комбінації стовпців таблиці будуть унікальними, тобто, жоден запис не буде дублюватися. Це обмеження забезпечує, щоб кожен запис у базі даних мав унікальне значення для вказаного стовпця або комбінації стовпців.

Як працює унікальне обмеження?

-   Якщо на стовпці встановлено унікальне обмеження, база даних не дозволяє вставити або оновити запис, де значення цього стовпця вже існує в іншому записі.
-   Унікальне обмеження можна застосувати до одного або кількох стовпців таблиці.

Приклад використання унікального обмеження

1. Унікальне обмеження на одному стовпці:

Наприклад, якщо ми хочемо, щоб назва книги в таблиці була унікальною (не було двох книг з однаковою назвою), ми можемо застосувати унікальне обмеження на поле title.

class Book(models.Model):

title = models.CharField(max_length=100, unique=True) # Унікальне  обмеження  на  поле title

 author = models.CharField(max_length=100)

У цьому випадку, поле title не дозволить створити два записи з однаковими назвами книг. Якщо спробуєте додати книгу з тією ж назвою, база даних викине помилку.

2. Унікальне обмеження на комбінацію полів (комбіноване унікальне обмеження):

Іноді потрібно, щоб комбінація значень з кількох стовпців була унікальною. Для  цього  використовують unique_together або UniqueConstraint у Django.

class Book(models.Model):

 title = models.CharField(max_length=100)

 author = models.CharField(max_length=100)

 class Meta:

unique_together = ['title', 'author'] # Унікальне  обмеження  на  комбінацію  полів

В цьому випадку база даних дозволить додавати записи лише за умови, що комбінація назви та автора буде унікальною. Тобто, можна мати кілька книг з однаковими назвами, якщо їх автори різні, але не можна додати дві книги з однаковими назвою та автором.

3. UniqueConstraint в Django 2.2+:

В Django 2.2 і пізніших версіях ви можете використовувати UniqueConstraint для реалізації унікальних обмежень на комбінації полів. Цей спосіб є більш гнучким і дозволяє використовувати умови для вибірки (наприклад, індексувати записи, які відповідають певним умовам).

class Book(models.Model):

 title = models.CharField(max_length=100)

 author = models.CharField(max_length=100)

 class Meta:

 constraints = [

 models.UniqueConstraint(fields=['title', 'author'], name='unique_title_author')

 ]

Тут UniqueConstraint забезпечує  унікальність  комбінації  полів title та author, а  також  дозволяє  вказати  ім'я  обмеження --- unique_title_author.

Інші  типи  обмежень (Constraints) в  базах  даних

1. PRIMARY KEY: Це спеціальне обмеження, яке вказує, що значення в цьому стовпці або в комбінації стовпців є унікальним і не може бути NULL. Кожен запис у таблиці має мати унікальний первинний ключ.

2. FOREIGN KEY: Це обмеження забезпечує зв'язок між двома таблицями, гарантуючи, що значення в стовпці або стовпцях існує в іншій таблиці (тобто, підтримує цілісність зв'язків між таблицями).

3. CHECK: Це обмеження перевіряє, чи задовольняє значення стовпця певним умовам. Наприклад, перевірка, чи є значення дати в межах певного діапазону.

4. NOT NULL: Це обмеження вказує, що стовпець не може містити NULL значення. Це гарантує, що кожен запис буде мати значення в цьому полі.

Переваги унікальних обмежень

1. Забезпечення цілісності даних: Унікальні обмеження гарантують, що дані в таблиці не будуть дублюватися, що важливо для забезпечення достовірності інформації.

2. Підвищення ефективності: Застосування унікальних обмежень на стовпці часто автоматично створює індекси, що дозволяє швидко перевіряти унікальність значень і покращує швидкість виконання запитів.

3. Бізнес-логіка: Унікальні обмеження дозволяють реалізувати бізнес-правила, наприклад, що кожен користувач може мати лише один електронний лист або телефонний номер у системі.

Недоліки унікальних обмежень

1. Знижує продуктивність операцій запису: Створення та підтримка унікальних обмежень може призвести до певних накладних витрат при виконанні операцій вставки або оновлення даних.

2. Обмежує гнучкість: Якщо дані в стовпці повинні бути унікальними лише в певних випадках (наприклад, для активних записів), іноді складно налаштувати відповідне обмеження.

Висновок

Унікальні обмеження в базах даних є важливим інструментом для забезпечення цілісності та правильності даних. Вони гарантують, що значення в певному стовпці або комбінації стовпців будуть унікальними, запобігаючи дублюванню записів у таблиці. Використання унікальних обмежень допомагає підтримувати високий рівень якості даних та забезпечує виконання певних бізнес-правил у додатках.

## **Що таке транзакція?** ACID

**Транзакція** в контексті баз даних --- це послідовність операцій, які виконуються як єдине ціле. Транзакції гарантують, що набір операцій, таких як вставка, оновлення чи видалення даних, буде виконаний або повністю, або не виконаний зовсім, якщо відбудеться яка-небудь помилка. Транзакції дозволяють забезпечити **цілісність даних** і **відновлення** після помилок.

**Основні властивості транзакцій (ACID)**

Транзакції у базах даних повинні відповідати чотирьом важливим властивостям, відомим під абревіатурою **ACID**:

1. **Atomicity (Атомарність)**:

o Операції транзакції виконуються як єдине ціле. Якщо одна з операцій не може бути виконана, всі попередні операції, виконані в межах цієї транзакції, скасовуються.

o Тобто, транзакція або виконується повністю, або не виконується взагалі.

2. **Consistency (Послідовність)**:

o Після виконання транзакції база даних повинна бути в консистентному стані. Це означає, що після виконання транзакції дані повинні відповідати всім визначеним правилам, обмеженням та логіці бізнесу.

o Наприклад, після транзакції сума грошей на рахунках у банку повинна бути правильною.

3. **Isolation (Ізоляція)**:

o Транзакції повинні бути ізольовані одна від одної, тобто одна транзакція не повинна впливати на виконання іншої. Транзакції не повинні бачити неповні або часткові зміни, виконані іншими транзакціями.

o Ізоляція забезпечується різними рівнями ізоляції транзакцій (наприклад, **READ COMMITTED**, **SERIALIZABLE**, **REPEATABLE READ**).

4. **Durability (Тривалість)**:

o Після того, як транзакція була успішно завершена, всі її зміни зберігаються в базі даних, навіть у разі системної помилки або збою.

o Наприклад, якщо сервер вимкнеться після коміту транзакції, зміни все одно збережуться.

**Як працює транзакція в базі даних?**

Транзакція в базі даних включає в себе такі етапи:

1. **Begin Transaction**: Транзакція починається. Всі операції виконуються в межах цієї транзакції, і база даних починає відстежувати зміни.

2. **Perform Operations**: Виконуються необхідні операції (наприклад, вставка, оновлення, видалення записів).

3. **Commit**: Якщо всі операції в межах транзакції були виконані успішно і немає помилок, транзакція **комітиться** --- зміни стають постійними і записуються в базу даних.

4. **Rollback**: Якщо виявляється помилка на будь-якому етапі транзакції, її можна скасувати за допомогою **rollback**. Всі зміни, зроблені в межах транзакції, будуть скасовані, і база даних повернеться до свого попереднього стану.

**Приклад транзакції в Django**

В Django транзакції можна використовувати за допомогою контекстного менеджера transaction.atomic(), який гарантує, що всі операції в межах цього блоку будуть виконані як одна транзакція.

from django.db import models, transaction

class Product(models.Model):

 name = models.CharField(max_length=100)

 price = models.DecimalField(max_digits=10, decimal_places=2)

# Використовуємо  транзакцію  для  гарантії  атомарності

with transaction.atomic():

 product = Product.objects.create(name="Laptop", price=1000)

# Інші  операції, які  виконуються  в  межах  тієї  ж  транзакції

 product.price = 950

 product.save()

# Якщо  в  межах  транзакції  сталася  помилка, всі  зміни  будуть  скасовані

У цьому прикладі:

-   Якщо одна з операцій не виконана, зміни будуть скасовані.
-   Якщо виникне помилка після вставки продукту, база даних повернеться до початкового стану і не збережеться жоден запис.

**Рівні ізоляції транзакцій**

Ізоляція транзакцій визначає, наскільки одна транзакція може взаємодіяти з іншими. Існує кілька рівнів ізоляції:

1. **READ UNCOMMITTED**: Один транзакцій може бачити незавершені зміни іншої транзакції (найменший рівень ізоляції).

2. **READ COMMITTED**: Транзакція бачить лише зміни, які були зафіксовані іншими транзакціями (найпоширеніший рівень).

3. **REPEATABLE READ**: Транзакція бачить лише ті дані, які були доступні на момент її початку, і жодна інша транзакція не може змінювати ці дані до її завершення.

4. **SERIALIZABLE**: Найвищий рівень ізоляції. Транзакції виконуються послідовно, одна за одною, так що жодна транзакція не може бачити часткові або незавершені зміни іншої.

**Приклад з рівнями ізоляції в Django**

У Django можна вказати рівень ізоляції за допомогою параметра isolation_level:

from django.db import connection

with transaction.atomic():

 connection.set_autocommit(False)

connection.isolation_level = 'SERIALIZABLE' # Встановлення  рівня  ізоляції

 # Виконання операцій

**Переваги використання транзакцій**

1. **Цілісність даних**: Транзакції дозволяють гарантувати, що в базі даних зберігається лише консистентна та коректна інформація.

2. **Безпека**: Якщо одна з операцій не може бути виконана, транзакція скасовує всі зміни, що допомагає уникнути часткових або неповних записів у базі.

3. **Відновлення після помилок**: Транзакції дозволяють відновити базу даних до стабільного стану, навіть у випадку збою системи.

**Недоліки транзакцій**

1. **Продуктивність**: Транзакції можуть уповільнити виконання операцій, особливо на великих обсягах даних, оскільки база даних повинна контролювати всі зміни та забезпечити їх атомарність.

2. **Ускладнення коду**: Використання транзакцій вимагає додаткової обробки помилок і управління ізоляцією.

**Висновок**

Транзакції в базах даних --- це потужний інструмент для забезпечення цілісності та коректності даних. Вони дозволяють виконувати кілька операцій як одну атомарну одиницю, що забезпечує надійність і консистентність даних у базі. Транзакції використовуються для запобігання помилок, обробки великих обсягів змін, а також для підтримки стабільності при роботі з базою даних.

## **Що таке агрегатні функції в SQL?** Наведіть приклади агрегатних функцій aggregate functions in SQL?**

**Агрегатні функції** в SQL --- це функції, які виконують операції над групою рядків і повертають єдине значення, яке є результатом цієї операції. Вони зазвичай використовуються в поєднанні з оператором GROUP BY для групування рядків за певним критерієм і виконання операцій над кожною групою.

Агрегатні функції допомагають виконувати статистичні операції, підсумки або аналіз даних, такі як підсумовування, підрахунок кількості записів, обчислення середнього значення тощо.

**Основні агрегатні функції в SQL**

1. **COUNT()**:

o Обчислює кількість рядків або непустих значень у стовпці.

o Найчастіше використовується для підрахунку кількості записів у таблиці або для підрахунку записів, що відповідають певному критерію.

**Приклад**:

SELECT COUNT(*) FROM employees;

-- Підраховує  кількість  усіх  працівників  у  таблиці employees

SELECT COUNT(DISTINCT department) FROM employees;

-- Підраховує  кількість  унікальних  відділів  у  таблиці employees

2. **SUM()**:

o Обчислює суму значень у числовому стовпці.

o Використовується для підсумовування всіх значень у стовпці або по кожній групі, якщо застосовано GROUP BY.

**Приклад**:

SELECT SUM(salary) FROM employees;

-- Підсумовує  заробітну  плату  всіх  працівників

SELECT department, SUM(salary) FROM employees GROUP BY department;

-- Підсумовує зарплату по кожному відділу

**3. ****AVG():**

o Обчислює середнє значення числового стовпця.

o Часто використовується для знаходження середнього значення для кожної групи або всієї таблиці.

**Приклад**:

SELECT AVG(salary) FROM employees;

-- Обчислює середню заробітну плату всіх працівників

SELECT department, AVG(salary) FROM employees GROUP BY department;

-- Обчислює середню зарплату по кожному відділу

4. **MIN()**:

o Повертає найменше значення у числовому або іншому порядковому стовпці.

o Зазвичай використовується для знаходження найменшого значення в групі або всій таблиці.

**Приклад**:

SELECT MIN(salary) FROM employees;

-- Повертає найменшу зарплату серед усіх працівників

SELECT department, MIN(salary) FROM employees GROUP BY department;

-- Повертає найменшу зарплату в кожному відділі

5. **MAX()**:

o Повертає найбільше значення у числовому або іншому порядковому стовпці.

o Використовується для знаходження максимального значення в групі або всій таблиці.

**Приклад**:

SELECT MAX(salary) FROM employees;

-- Повертає найбільшу зарплату серед усіх працівників

SELECT department, MAX(salary) FROM employees GROUP BY department;

-- Повертає найбільшу зарплату по кожному відділу

6. **GROUP_CONCAT()** (MySQL) або **STRING_AGG()** (PostgreSQL, SQL Server):

o Агрегує рядки в одну строку, зазвичай через заданий роздільник.

o Часто використовується для створення списків значень з кількох рядків.

**Приклад**** (MySQL)**:

SELECT department, GROUP_CONCAT(name) FROM employees GROUP BY department;

-- Повертає список імен працівників для кожного відділу, розділених комами

**Приклад**** (PostgreSQL)**:

SELECT department, STRING_AGG(name, ', ') FROM employees GROUP BY department;

-- Повертає список імен працівників для кожного відділу, розділених комами

**Використання агрегатних функцій з GROUP BY**

Агрегатні функції часто використовуються разом з оператором GROUP BY, щоб виконувати обчислення для окремих груп записів. Наприклад, можна підсумувати зарплати або підрахувати кількість працівників в кожному відділі:

SELECT department, AVG(salary) AS average_salary

FROM employees

GROUP BY department;

-- Обчислює середню зарплату по кожному відділу

**Використання агрегатних функцій з умовами**

Агрегатні функції можна комбінувати з умовами, наприклад, з WHERE або HAVING. WHERE обмежує рядки до того, як буде виконано групування, а HAVING обмежує результати після групування.

**Приклад** (використання WHERE):

SELECT department, SUM(salary) AS total_salary

FROM employees

WHERE hire_date > '2020-01-01'

GROUP BY department;

-- Підсумовує  зарплату  працівників, які  були  прийняті  після 1 січня 2020 року, по  кожному  відділу

**Приклад** (використання HAVING):

SELECT department, AVG(salary) AS average_salary

FROM employees

GROUP BY department

HAVING AVG(salary) > 50000;

-- Показує відділи, де середня зарплата більша за 50 000

**Висновок**

Агрегатні функції в SQL --- це інструмент для аналізу даних, який дозволяє виконувати статистичні операції над групами записів. Вони допомагають підсумовувати, підраховувати, знаходити середні значення або мінімальні/максимальні значення, що є основою для отримання корисної інформації з великих обсягів даних.

## **Стиль коду в SQL.?** Code style in SQL

Стиль коду в SQL важливий для підвищення читабельності та підтримки коду. Ось кілька рекомендацій щодо стилю написання SQL-запитів:

**1\. Використання верхнього регістру для ключових слів**

Ключові слова SQL, такі як SELECT, FROM, WHERE, JOIN, INSERT, UPDATE, DELETE, пишуться великими літерами. Це дозволяє швидко відрізняти команди SQL від інших частин запиту (наприклад, назв таблиць або стовпців).

SELECT first_name, last_name

FROM employees

WHERE department = 'Sales';

**2\. Відступи та вирівнювання**

Використовуйте відступи для підвищення читабельності. Зазвичай це 2 або 4 пробіли. Рядки повинні бути вирівняні так, щоб їх легко було читати.

SELECT first_name, last_name

 FROM employees

WHERE department = 'Sales'

AND hire_date > '2020-01-01';

**3\. Новий рядок для кожного елементу**

Кожну частину запиту (наприклад, кожну умову в WHERE або кожну таблицю в JOIN) слід писати в новому рядку.

SELECT first_name, last_name

 FROM employees

JOIN departments ON employees.department_id = departments.id

WHERE department = 'Sales'

AND hire_date > '2020-01-01';

**4\. ****Використання****явних****об****'****єднань**

Якщо  використовуєте JOIN, завжди  вказуйте  тип  з'єднання (наприклад, INNER JOIN, LEFT JOIN). Це  робить  код  більш  зрозумілим.

SELECT e.first_name, e.last_name, d.department_name

 FROM employees e

LEFT JOIN departments d ON e.department_id = d.id

WHERE e.hire_date > '2020-01-01';

**5\. Використання псевдонімів**

Використання псевдонімів допомагає зробити запит компактним, але при цьому важливо, щоб вони були зрозумілими та короткими.

SELECT e.first_name, e.last_name, d.department_name

 FROM employees AS e

LEFT JOIN departments AS d ON e.department_id = d.id;

**6\. Коми в кінці рядків**

У SQL кома повинна стояти в кінці рядка, а не на початку наступного, щоб було зручно додавати нові стовпці чи умови.

SELECT first_name,

 last_name,

 department

FROM employees;

**7\. ****Послідовність****в****іменах**

Дотримуйтесь  однієї  конвенції  для  іменування  таблиць, стовпців  та  інших  об'єктів  бази  даних.  Наприклад:

-   Використання нижнього регістру з підкресленнями для розділення слів (first_name, employee_id).
-   Або  використання camelCase (firstName, employeeId).

**8\. Форматування для складних підзапитів**

Для складних підзапитів або вкладених запитів використовуйте відступи, щоб вони були легко читаються.

SELECT first_name, last_name

 FROM employees

WHERE department = 'Sales'

 AND hire_date > (

SELECT MAX(hire_date)

FROM employees

 WHERE department = 'Sales' );

**9\. ****Коментарі**

Використовуйте  коментарі, щоб  пояснити  складні  чи  важливі  частини  коду.

-- Вибираємо  імена  співробітників  з  відділу "Продажі"

SELECT first_name, last_name

FROM employees

WHERE department = 'Sales';

**10\. ****Запити****з****великою****кількістю****даних**

Якщо запит повертає велику кількість рядків, використовуйте LIMIT або TOP, щоб обмежити результати для тестування.

SELECT first_name, last_name

 FROM employees

LIMIT 10;

Дотримуючись цих рекомендацій, можна створити чистий, легко читабельний та підтримуваний SQL-код.

## **Що таке псевдонім? Типи псевдонімів** **What****is****alias****? ****Types of aliases**

**Псевдонім** (alias) --- це  тимчасове  ім'я, яке  дається  таблиці  або  стовпцю  в SQL-запиті  для  зручності, скорочення  або  покращення  читабельності. Псевдоніми допомагають зробити запити компактнішими та зрозумілішими, особливо коли працюєш з великими або складними запитами, де є багато таблиць або стовпців.

**Типи псевдонімів в SQL**

1. **Псевдонім для таблиць (Table Alias)**: Псевдонім для таблиці використовується для того, щоб скоротити назву таблиці, особливо якщо вона довга, або якщо запит має кілька таблиць, що з'єднуються (JOIN). Це робить запит більш зручним для написання та читання.

**Синтаксис:**

SELECT t.first_name, t.last_name

 FROM employees AS t;

У  цьому  прикладі  таблиця employees отримує  псевдонім t. Тепер  можна  використовувати t замість  повної  назви  таблиці.

2. **Псевдонім****для****стовпців**** (Column Alias)**:  Псевдонім  для  стовпця  дозволяє  змінити  або  скоротити  ім'я  стовпця  в  результатах  запиту. Це особливо корисно, коли стовпець має складне або довге ім'я, або коли ви створюєте нові обчислені стовпці.

**Синтаксис****:**

SELECT first_name AS "First Name", last_name AS "Last Name"

 FROM employees;

У  цьому  прикладі  стовпці first_name і last_name отримують  псевдоніми "First Name" і "Last Name" відповідно.

3. **Псевдонім****для****обчислених****стовпців**** (Calculated Column Alias****)**: Якщо  ви  використовуєте  вирази  для  створення  нових  стовпців (наприклад, за  допомогою  функцій  або  арифметичних  операцій), можна  призначити  псевдонім  для  нового  обчисленого  стовпця.

**Синтаксис****:**

SELECT salary * 12 AS annual_salary

 FROM employees;

У  цьому  прикладі  вираз salary * 12 обчислює  річну  зарплату, а  псевдонім annual_salary робить  цей  стовпець  зрозумілим.

4. **Псевдонім для підзапитів (Subquery Alias)**: Коли ви використовуєте підзапити (запити в запитах), потрібно призначити псевдонім для результатів підзапиту, щоб з ним можна було працювати, наприклад, у JOIN або WHERE.

**Синтаксис****:**

SELECT a.first_name, a.last_name

 FROM (SELECT first_name, last_name FROM employees WHERE department = 'Sales') AS a;

У цьому прикладі підзапит отримує псевдонім a, що дозволяє використовувати його результати в основному запиті.

Псевдоніми роблять SQL-запити більш зручними, легкими для читання та підтримки, особливо у випадку великих або складних запитів з кількома таблицями, стовпцями або підзапитами.

## **Яка різниця між WHERE і HAVING?** What is the difference between WHERE and HAVING?**

У SQL **WHERE** та **HAVING** --- це два оператори, які використовуються для фільтрації даних, але вони мають різні призначення та застосовуються на різних етапах виконання запиту.

**1\. WHERE**

-   **Призначення**: Використовується для фільтрації рядків до того, як вони будуть згруповані (якщо є групування) або до виконання інших операцій, таких як агрегація.
-   **Коли застосовується**: WHERE фільтрує дані на етапі вибору (перед групуванням або агрегацією).
-   **Які поля можна використовувати**: Можна використовувати будь-які стовпці таблиці (звичайні стовпці, без необхідності виконання агрегаційних функцій).

**Приклад**:

SELECT first_name, last_name

 FROM employees

WHERE department = 'Sales';

В цьому прикладі WHERE фільтрує рядки перед тим, як вони будуть оброблені будь-якими агрегатними функціями.

**2\. HAVING**

-   **Призначення**: Використовується для фільтрації після того, як дані вже були згруповані або агреговані. Зазвичай застосовується разом з групуваннями, що виконуються через GROUP BY.
-   **Коли застосовується**: HAVING фільтрує результати після виконання агрегацій або групувань (після обчислення функцій, таких як SUM(), AVG(), COUNT() тощо).
-   **Які поля можна використовувати**: Зазвичай використовується з агрегатними функціями або після групування.

**Приклад**:

SELECT department, COUNT(*) AS num_employees

 FROM employees

GROUP BY department

HAVING COUNT(*) > 10;

Тут HAVING використовується  для  фільтрації  груп, де  кількість  співробітників  у  відділі  більше 10, після  того  як  дані  були  згруповані  за  відділами.

**Основні відмінності:**

|

**Критерій**

 |

**WHERE**

 |

**HAVING**

 |
| --- | --- | --- |
|

**Етап виконання**

 |

До агрегації (групування)

 |

Після агрегації (після групування)

 |
|

**Тип даних**

 |

Використовується для стовпців таблиці (не агрегаційних)

 |

Використовується для агрегатних функцій або груп

 |
|

**Застосування**

 |

Для фільтрації рядків до GROUP BY

 |

Для фільтрації після GROUP BY

 |

**Приклад****:WHERE:**

SELECT first_name, last_name, department

 FROM employees

WHERE hire_date > '2020-01-01';

У цьому прикладі WHERE фільтрує рядки, де дата прийому на роботу більша за 1 січня 2020 року.

**HAVING:**

SELECT department, AVG(salary) AS avg_salary

FROM employees

GROUP BY department

HAVING AVG(salary) > 50000;

Тут HAVING фільтрує групи відділів, де середня зарплата більша за 50 000 після того, як відбулося групування.

**Підсумок:**Використовуйте **WHERE** для фільтрації рядків **до** агрегації. Використовуйте **HAVING** для фільтрації результатів **після** агрегації або групування.

## **Що таке таблиця і поле?** Table & field

У контексті SQL та баз даних:

1\. Таблиця (Table)

Таблиця --- це основна структура для зберігання даних у реляційній базі даних. Вона являє собою набір рядків і стовпців, де кожен рядок (також званий записом) містить дані, що стосуються певного об'єкта чи сутності, а кожен стовпець (також званий полем) містить дані певного типу для кожного об'єкта.

Основні характеристики таблиці: Назва таблиці: кожна таблиця має свою унікальну назву, через яку з нею звертаються. Рядки: кожен рядок представляє окремий запис або об'єкт. Наприклад, у таблиці "співробітники" кожен рядок буде містити інформацію про одного співробітника. Стовпці: кожен стовпець представляє певну характеристику або атрибут об'єкта. Наприклад, у таблиці "співробітники" стовпці можуть бути такими, як "ім'я", "посада", "зарплата".

Приклад таблиці:

|

id

 |

first_name

 |

last_name

 |

department

 |

hire_date

 |
| --- | --- | --- | --- | --- |
|

1

 |

John

 |

Doe

 |

HR

 |

2020-05-01

 |
|

2

 |

Jane

 |

Smith

 |

Sales

 |

2019-08-15

 |
|

3

 |

Jim

 |

Brown

 |

IT

 |

2021-01-10

 |

У цьому прикладі таблиця employees містить інформацію про співробітників з такими стовпцями, як id, first_name, last_name, department, і hire_date.

**2\. Поле (Field або Column)**

**Поле (або стовпець)** --- це окремий атрибут або характеристика, що містить однорідні дані для кожного запису (рядка) в таблиці. Кожен стовпець має ім'я і тип даних, який визначає, яку інформацію він зберігає (наприклад, текст, число, дата тощо).

Основні характеристики поля:

-   Назва поля: кожен стовпець має свою назву (наприклад, first_name, salary, hire_date).
-   Тип даних: кожне поле має визначений тип даних (наприклад, VARCHAR для текстових значень, INT для цілих чисел, DATE для дат).
-   Значення: значення в кожному полі однакові для всіх записів у колонці. Наприклад, у полі first_name будуть зберігатися тільки імена співробітників.

Приклад поля в таблиці: У наведеному прикладі таблиці employees, поля можуть бути наступними:

-   first_name: зберігає імена співробітників (тип даних може бути VARCHAR).
-   hire_date: зберігає дати прийому на роботу співробітників (тип даних --- DATE).

У таблиці кожен стовпець має певний тип даних і містить тільки значення цього типу для кожного запису. Наприклад, стовпець hire_date містить лише дати, а стовпець first_name містить лише текстові значення.

Підсумок:

-   Таблиця --- це структура для зберігання даних у вигляді рядків і стовпців.
-   Поле (стовпець) --- це окремий атрибут або характеристика в таблиці, який містить однорідні дані для кожного запису.

## **Які різні оператори доступні в SQL?** What are the different operators available in SQL?**

В SQL є багато операторів, які виконують різні операції на даних. Оператори можна поділити на кілька категорій залежно від їх призначення. Ось основні категорії операторів у SQL:

1\. Оператори порівняння (Comparison Operators)

Оператори порівняння використовуються для порівняння значень. Вони зазвичай використовуються в умовах (WHERE, HAVING), щоб визначити, чи задовольняють рядки певні умови.

-   = --- дорівнює
-   != або <> --- не дорівнює
-   > --- більше
-   < --- менше
-   >= --- більше або дорівнює
-   <= --- менше або дорівнює
-   BETWEEN --- перевіряє, чи належить значення певному діапазону
-   IN --- перевіряє, чи міститься значення в наборі значень
-   LIKE --- перевіряє, чи збігається значення з шаблоном
-   IS NULL --- перевіряє, чи значення є NULL
-   IS NOT NULL --- перевіряє, чи значення не є NULL

Приклад:

SELECT * FROM employees WHERE salary > 50000;

2\. Логічні оператори (Logical Operators)

Логічні оператори використовуються для комбінування кількох умов у запитах.

-   AND --- логічне "І", повертає TRUE, якщо всі умови виконуються
-   OR --- логічне "АБО", повертає TRUE, якщо хоча б одна умова виконується
-   NOT --- заперечує умову, повертає TRUE, якщо умова не виконується

Приклад:

SELECT * FROM employees WHERE department = 'Sales' AND salary > 50000;

3\. Оператори для роботи з рядками (String Operators)

Оператори для роботи з рядками використовуються для маніпуляцій з текстовими даними.

-   CONCAT() --- об'єднує два або більше рядка в один
-   LIKE --- перевіряє відповідність рядка шаблону
-   SUBSTRING() --- витягує частину рядка
-   LENGTH() --- визначає довжину рядка
-   UPPER() --- перетворює рядок на великі літери
-   LOWER() --- перетворює рядок на малі літери

Приклад:

SELECT CONCAT(first_name, ' ', last_name) AS full_name FROM employees;

4\. Агрегатні оператори (Aggregate Operators)

Агрегатні оператори застосовуються для обчислення значень над групами рядків, наприклад, під час використання GROUP BY.

-   COUNT() --- обчислює кількість рядків
-   SUM() --- обчислює суму значень
-   AVG() --- обчислює середнє значення
-   MIN() --- знаходить мінімальне значення
-   MAX() --- знаходить максимальне значення

Приклад:

SELECT department, AVG(salary) AS avg_salary FROM employees GROUP BY department;

5\. Оператори для роботи з датами та часом (Date and Time Operators)

Оператори для роботи з датами дозволяють маніпулювати та порівнювати значення типу дата і час.

-   CURRENT_DATE --- поточна дата
-   CURRENT_TIME --- поточний час
-   DATE() --- витягує дату з datetime
-   YEAR(), MONTH(), DAY() --- отримує рік, місяць або день з дати
-   DATEDIFF() --- обчислює різницю між двома датами
-   NOW() --- поточний час з датою

Приклад:

SELECT * FROM employees WHERE hire_date > '2022-01-01';

6\. Оператори для роботи з підзапитами (Subquery Operators)

Підзапити використовуються для виконання запиту всередині іншого запиту.

-   EXISTS --- перевіряє, чи існує результат у підзапиті
-   ANY --- порівнює значення з будь-яким значенням з підзапиту
-   ALL --- порівнює значення з усіма значеннями з підзапиту
-   IN --- перевіряє, чи значення входить до набору значень підзапиту

Приклад:

SELECT first_name FROM employees WHERE department IN (SELECT department FROM departments WHERE location = 'New York');

7\. Оператори для об'єднання запитів (Set Operators)

Оператори об'єднання використовуються для об'єднання результатів двох або більше запитів.

-   UNION --- об'єднує результати двох запитів, усуваючи дублікати
-   UNION ALL --- об'єднує результати двох запитів, включаючи дублікати
-   INTERSECT --- повертає лише спільні рядки з двох запитів
-   EXCEPT (або MINUS в деяких СУБД) --- повертає рядки, які є в першому запиті, але відсутні в другому

Приклад:

SELECT department FROM employees

UNION

SELECT department FROM contractors;

8\. Оператори  для  створення  та  зміни  таблиць (DDL - Data Definition Language)

Оператори DDL використовуються для створення та зміни структури бази даних.

-   CREATE --- створення нових об'єктів (таблиць, баз даних, індексів)
-   ALTER --- зміна структури існуючих об'єктів (додавання стовпців, зміна типів даних)
-   DROP --- видалення об'єктів (таблиць, баз даних, індексів)
-   TRUNCATE --- видалення всіх рядків з таблиці, але зберігаючи структуру таблиці

Приклад:

CREATE TABLE employees (

    id INT PRIMARY KEY,

    first_name VARCHAR(50),

    last_name VARCHAR(50),

    department VARCHAR(50)

);

9\. Оператори  для  управління  транзакціями (DCL - Data Control Language)

Ці оператори використовуються для контролю доступу до даних.

-   GRANT --- надає користувачам права на виконання операцій
-   REVOKE --- забирає права користувачів

Приклад:

GRANT SELECT, INSERT ON employees TO user1;

Підсумок:

SQL пропонує  широкий  набір  операторів  для  виконання  різних  операцій  з  даними, включаючи  порівняння, логіку, агрегацію, маніпуляції  з  рядками  та  датами, а  також  для  управління  транзакціями  та  структугою  бази  даних.

## **Explain SQL Order by statement**?

**ORDER****BY** --- це оператор SQL, який використовується для сортування результатів запиту за певними стовпцями. Він дозволяє визначити порядок рядків у результатах: відсортовані дані можуть бути впорядковані за зростанням або спаданням.

**Основний****синтаксис****:**

SELECT column1, column2, ...

FROM table_name

ORDER BY column1 [ASC|DESC], column2 [ASC|DESC], ...;

-   **column1, column2** --- це назви стовпців, за якими ви хочете сортувати результати.
-   **ASC** (за замовчуванням) --- сортування за зростанням (від найменшого до найбільшого). Це означає, що для чисел сортується від найменшого до найбільшого, для тексту --- від A до Z, для дат --- від найранішої до найпізнішої.
-   **DESC** --- сортування за спаданням (від найбільшого до найменшого). Для чисел це від найбільшого до найменшого, для тексту --- від Z до A, для дат --- від найпізнішої до найраннішої.

**Приклад 1: Сортування за одним стовпцем**

У цьому прикладі ми сортуємо результати за зростанням значень стовпця salary:

SELECT first_name, last_name, salary

FROM employees

ORDER BY salary ASC;

Цей запит повертає співробітників, відсортованих за їхньою зарплатою від найменшої до найбільшої.

**Приклад 2: Сортування за спаданням**

У цьому прикладі ми сортуємо співробітників за зарплатою в порядку спадання:

SELECT first_name, last_name, salary

FROM employees

ORDER BY salary DESC;

Цей запит повертає співробітників, відсортованих за їхньою зарплатою від найбільшої до найменшої.

**Приклад 3: Сортування за кількома стовпцями**

Ми можемо сортувати результат за кількома стовпцями одночасно. У цьому прикладі спочатку сортуємо за відділом (department), а потім за зарплатою всередині кожного відділу:

SELECT first_name, last_name, department, salary

FROM employees

ORDER BY department ASC, salary DESC;

У цьому запиті:

-   Співробітники спочатку будуть відсортовані за алфавітним порядком їхніх відділів (від A до Z).
-   Потім всередині кожного відділу співробітники будуть відсортовані за зарплатою від найбільшої до найменшої.

**Приклад 4: Сортування за кількома типами даних**

Можна сортувати за стовпцями, що мають різні типи даних, наприклад, по даті:

SELECT first_name, last_name, hire_date

FROM employees

ORDER BY hire_date ASC, last_name DESC;

Цей запит:

-   Спершу сортує співробітників за датою прийому на роботу (від найранішої до найпізнішої).
-   Потім всередині однієї і тієї ж дати співробітники сортуються за прізвищем від Z до A.

**Особливості використання ORDER BY:**

-   **За замовчуванням сортування** відбувається у порядку зростання (ASC), тому можна не вказувати явно ASC, якщо це не потрібно.
-   **Сортування по кількості рядків**: можна також використовувати ORDER BY разом з іншими операціями, як, наприклад, **LIMIT** для обмеження кількості результатів:

SELECT * FROM employees

ORDER BY salary DESC

LIMIT 5;

Цей запит поверне 5 співробітників з найбільшими зарплатами.

-   **Сортування по виразу**: можна сортувати за результатами виразів або обчислень:

SELECT first_name, last_name, salary * 12 AS annual_salary

FROM employees

ORDER BY annual_salary DESC;

**Підсумок:**

-   Оператор **ORDER BY** дозволяє сортувати результати запиту за одним або кількома стовпцями.
-   Можна використовувати **ASC** для сортування за зростанням (за замовчуванням) або **DESC** для сортування за спаданням.
-   Оператор **ORDER BY** особливо корисний для упорядкування великих обсягів даних та для визначення найкращих чи найгірших значень в наборі результатів.


1. [**Що таке база даних?**](#що-таке-база-даних-whatisdatabase)
2. [**Що таке SQL?**](#що-таке-sql-sql)
3. [**Що таке параметризація?**](#що-таке-параметризація-sql-інєкція-what-is-parametrization-sql-injection)
4. [**What is connection/cursor?**](#what-is-connectioncursor-щотакепідключеннякурсор)
5. [**CRUD**](#crud)
6. [**Як працює ORM?**](#як-працює-orm)
7. [**Як manage.py is used?**](#for-what-purposes-managepy-is-used)
8. [**settings.py**](#settingspy)
9. [**Моделі (models)**?](#моделі-models)
10. [**Що таке migrations?**](#що-таке-migrations)
11. [**QuerySet**** в ****Django**?](#queryset-в-django)
12. [**Які різні поля в Django ORM ви знаєте**?](#які-різні-поля-в-django-orm-ви-знаєте-перелічіть-усіwhich-different-fields-in-django-orm-you-know-list-all-of-them)
13. [**Яка різниця між null і blank?**](#яка-різниця-між-null-і-blankwhat-is-the-difference-between-null-and-blank)
14. [**Що таке field choices**?](#що-таке-field-choices)
15. [**Які відносини ви знаєте**.?](#яківідносинивизнаєте-what-kind-of-relations-you-know)
16. [**Що означають різні параметри on_delete?**](#що-означають-різні-параметри-on_delete)
17. [**Що таке зворотні відносини**?](#що-таке-зворотні-відносини-what-are-backward-relations)
18. [**Яке призначення проміжної таблиці (багато-до-багатьох)?**](#яке-призначення-проміжної-таблиці-багато-до-багатьох-many-to-many)
19. [**Що таке менеджери**?](#що-таке-менеджери-what-are-managers)
20. [**Що означає фраза Querysets are lazy?**](#що-означає-фраза-querysets-are-lazy)
21. [**Що таке пошуки?lookups?**](#що-таке-пошукиlookups)
22. [**Як об'єднання реалізовано в Django ORM?**](#як-обєднання-реалізовано-в-django-orm-how-joins-are-implemented-in-django-orm)
23. [**Що таке кешування набору запитів?**](#що-таке-кешування-набору-запитів-queryset-caching)
24. [**Що таке анотації / агрегації**?](#що-таке-анотації--агрегації-annotationsaggregations)
25. [**Для чого використовуються select_related/prefetch_related?**](#для-чого-використовуються-select_relatedprefetch_related-what-are-select_relatedprefetch_related-used-for)
26. [**Що таке клас Meta?**](#що-таке-клас-meta)
27. [**Що таке індекси бази даних ?**](#що-таке-індекси-бази-даних--what-are-database-indexes)
28. [**Що таке обмеження (****унікальні****)?**](#що-таке-обмеження-унікальні-what-are-constraints-unique)
29. [**Що таке транзакція?**](#що-таке-транзакція-acid)
30. [**Що таке агрегатні функції в SQL?**](#що-таке-агрегатні-функції-в-sql-наведіть-приклади-агрегатних-функцій-aggregate-functions-in-sql)
31. [**Стиль коду в SQL.?**](#стиль-коду-в-sql-code-style-in-sql)
32. [**Що таке псевдонім? Типи псевдонімів**?](#що-таке-псевдонім-типи-псевдонімів-whatisalias-types-of-aliases)
33. [**Яка різниця між WHERE і HAVING?**](#яка-різниця-між-where-і-having-what-is-the-difference-between-where-and-having)
34. [**Що таке таблиця і поле?**](#що-таке-таблиця-і-поле-table--field)
35. [**Які різні оператори доступні в SQL?**](#які-різні-оператори-доступні-в-sql-what-are-the-different-operators-available-in-sql)
36. [*Explain SQL Order by statement**?](#explain-sql-order-by-statement)

